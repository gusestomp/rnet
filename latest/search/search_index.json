{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"rnet","text":"<p>\ud83d\ude80 Help me work seamlessly with open source sharing by sponsoring me on GitHub</p> <p>An ergonomic and modular Python HTTP client for advanced and low-level emulation, featuring customizable TLS, JA3/JA4, and HTTP/2 fingerprinting capabilities, powered by wreq.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Async and Blocking <code>Client</code>s</li> <li>Plain bodies, JSON, urlencoded, multipart</li> <li>HTTP Trailer</li> <li>Cookie Store</li> <li>Redirect Policy</li> <li>Original Header</li> <li>Rotating Proxies</li> <li>Connection Pooling</li> <li>Streaming Transfers</li> <li>Zero-Copy Transfers</li> <li>WebSocket Upgrade</li> <li>HTTPS via BoringSSL</li> <li>Free-Threaded Safety</li> <li>Automatic Decompression</li> <li>Certificate Store (CAs &amp; mTLS)</li> </ul>"},{"location":"#example","title":"Example","text":"<p>The following example uses the <code>asyncio</code> runtime with <code>rnet</code> installed via pip:</p> <pre><code>pip install asyncio rnet --pre --upgrade\n</code></pre> <p>And then the code:</p> <pre><code>import asyncio\nfrom rnet import Client, Emulation\n\n\nasync def main():\n    # Build a client\n    client = Client(emulation=Emulation.Safari26)\n\n    # Use the API you're already familiar with\n    resp = await client.get(\"https://tls.peet.ws/api/all\")\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Additional learning resources include:</p> <ul> <li>Documentation</li> <li>Synchronous Examples</li> <li>Asynchronous Examples</li> </ul>"},{"location":"#behavior","title":"Behavior","text":"<ol> <li>HTTP/2 over TLS</li> </ol> <p>Due to the complexity of TLS encryption and the widespread adoption of HTTP/2, browser fingerprints such as JA3, JA4, and Akamai cannot be reliably emulated using simple fingerprint strings. Instead of parsing and emulating these string-based fingerprints, <code>rnet</code> provides fine-grained control over TLS and HTTP/2 extensions and settings for precise browser behavior emulation.</p> <ol> <li>Device Emulation</li> </ol> <p>Most browser device models share identical TLS and HTTP/2 configurations, differing only in the <code>User-Agent</code> string.</p> Available OS emulations OS Description Windows Windows (any version) MacOS macOS (any version) Linux Linux (any distribution) Android Android (mobile) iOS iOS (iPhone/iPad) Available browser emulations Browser Versions Chrome <code>Chrome100</code>, <code>Chrome101</code>, <code>Chrome104</code>, <code>Chrome105</code>, <code>Chrome106</code>, <code>Chrome107</code>, <code>Chrome108</code>, <code>Chrome109</code>, <code>Chrome110</code>, <code>Chrome114</code>, <code>Chrome116</code>, <code>Chrome117</code>, <code>Chrome118</code>, <code>Chrome119</code>, <code>Chrome120</code>, <code>Chrome123</code>, <code>Chrome124</code>, <code>Chrome126</code>, <code>Chrome127</code>, <code>Chrome128</code>, <code>Chrome129</code>, <code>Chrome130</code>, <code>Chrome131</code>, <code>Chrome132</code>, <code>Chrome133</code>, <code>Chrome134</code>, <code>Chrome135</code>, <code>Chrome136</code>, <code>Chrome137</code>, <code>Chrome138</code>, <code>Chrome139</code>, <code>Chrome140</code>, <code>Chrome141</code>, <code>Chrome142</code>, <code>Chrome143</code> Safari <code>SafariIos17_2</code>, <code>SafariIos17_4_1</code>, <code>SafariIos16_5</code>, <code>Safari15_3</code>, <code>Safari15_5</code>, <code>Safari15_6_1</code>, <code>Safari16</code>, <code>Safari16_5</code>, <code>Safari17_0</code>, <code>Safari17_2_1</code>, <code>Safari17_4_1</code>, <code>Safari17_5</code>, <code>Safari18</code>, <code>SafariIPad18</code>, <code>Safari18_2</code>, <code>SafariIos18_1_1</code>, <code>Safari18_3</code>, <code>Safari18_3_1</code>, <code>Safari18_5</code>,  <code>Safari26</code>, <code>Safari26_1</code>, <code>Safari26_2</code>, <code>SafariIos26</code>, <code>SafariIos26_2</code>, <code>SafariIPad26</code>, <code>SafariIPad26_2</code> Firefox <code>Firefox109</code>, <code>Firefox117</code>, <code>Firefox128</code>, <code>Firefox133</code>, <code>Firefox135</code>, <code>FirefoxPrivate135</code>, <code>FirefoxAndroid135</code>, <code>Firefox136</code>, <code>FirefoxPrivate136</code>, <code>Firefox139</code>, <code>Firefox142</code>, <code>Firefox143</code>, <code>Firefox144</code>, <code>Firefox145</code>, <code>Firefox146</code> OkHttp <code>OkHttp3_9</code>, <code>OkHttp3_11</code>, <code>OkHttp3_13</code>, <code>OkHttp3_14</code>, <code>OkHttp4_9</code>, <code>OkHttp4_10</code>, <code>OkHttp4_12</code>, <code>OkHttp5</code> Edge <code>Edge101</code>, <code>Edge122</code>, <code>Edge127</code>, <code>Edge131</code>, <code>Edge134</code>, <code>Edge135</code>, <code>Edge136</code>, <code>Edge137</code>, <code>Edge138</code>, <code>Edge139</code>, <code>Edge140</code>, <code>Edge141</code>, <code>Edge142</code> Opera <code>Opera116</code>, <code>Opera117</code>, <code>Opera118</code>, <code>Opera119</code>"},{"location":"#building","title":"Building","text":"<ol> <li> <p>Platforms</p> </li> <li> <p>Linux(glibc/musl): <code>x86_64</code>, <code>aarch64</code>, <code>armv7</code>, <code>i686</code></p> </li> <li>macOS: <code>x86_64</code>,<code>aarch64</code></li> <li>Windows: <code>x86_64</code>,<code>i686</code>,<code>aarch64</code></li> <li> <p>Android: <code>aarch64</code>, <code>x86_64</code></p> </li> <li> <p>Development</p> </li> </ol> <p>Install the BoringSSL build environment by referring to boring and boringssl.</p> <pre><code># on ubuntu or debian\nsudo apt install -y build-essential cmake perl pkg-config libclang-dev musl-tools git\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\npip install uv maturin\n\nuv venv\nsource .venv/bin/activate\n\n# development\nmaturin develop --uv\n\n# build wheels\nmaturin build --release\n</code></pre>"},{"location":"#benchmark","title":"Benchmark","text":"<p>Outperforms <code>requests</code>, <code>httpx</code>, <code>aiohttp</code>, and <code>curl_cffi</code>, and you can see the benchmark for details \u2014 benchmark data is for reference only and actual performance may vary based on your environment and use case.</p>"},{"location":"#services","title":"Services","text":"<p>Help sustain the ongoing development of this open-source project by reaching out for commercial support. Receive private guidance, expert reviews, or direct access to the maintainer, with personalized technical assistance tailored to your needs.</p>"},{"location":"#license","title":"License","text":"<p>Licensed under either of Apache License, Version 2.0 (LICENSE or http://www.apache.org/licenses/LICENSE-2.0).</p>"},{"location":"#contribution","title":"Contribution","text":"<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be licensed as above, without any additional terms or conditions.</p>"},{"location":"sponsors/","title":"Sponsors","text":"<p>We're grateful for the support of our sponsors who help make this project possible.</p>"},{"location":"sponsors/#scrapedo","title":"Scrape.do","text":"<p>Scrape.do is the ultimate toolkit for collecting public data at scale. Unmatched speed, unbeatable prices, unblocked access.</p> <p>One line of code. Instant data access</p> <p>\ud83d\udd01 Automatic Proxy Rotation \ud83e\udd16 Bypass Anti-bot Solutions  \u26cf\ufe0f Seamless Web Scraping</p> <p>\ud83d\ude80 Register | \ud83d\udc54 Linkedin | \ud83d\udcd6 Docs</p> <p> </p>"},{"location":"sponsors/#ezcaptcha","title":"EzCaptcha","text":"<p>Captcha solving can be slow and unreliable, but EzCaptcha delivers fast, reliable solving through a simple API \u2014 supporting a wide range of captcha types with no complex integration required.  </p> <p>ReCaptcha \u2022 FunCaptcha \u2022 CloudFlare \u2022 Akamai \u2022 AkamaiSbsd \u2022 HCaptcha </p> <p>Designed for developers, it offers high accuracy, low price, low latency, and easy integration, helping you automate verification while keeping traffic secure and user flows smooth.</p> <p>\ud83d\ude80 Get API Key | \ud83d\udcd6 Docs | \ud83d\udcac Telegram</p> <p> </p>"},{"location":"sponsors/#thordata","title":"Thordata","text":"<p>Thordata: Get Reliable Global Proxies at an Unbeatable Value. </p> <p>One-click data collection with enterprise-grade stability and compliance. Join thousands of developers using ThorData for high-scale operations.</p> <p>Exclusive Offer: Sign up for a free Residential Proxy trial and 2,000 FREE SERP API calls!</p> <p>\ud83d\udc54 Linkedin | \ud83d\udcac Discord | \u2708\ufe0f Telegram</p> <p> </p>"},{"location":"sponsors/#salamoonder","title":"Salamoonder","text":"<p>Anti-bots evolve quickly, but Salamoonder moves faster, delivering reliable anti-bot tokens with just two API requests \u2014 no browser automation or unnecessary complexity required.  </p> <p>Kasada \u2022 Incapsula \u2022 Datadome \u2022 Akamai \u2022 And many more </p> <p>Automatic updates keep your integration simple and low-maintenance, and it's nearly 50% cheaper than the competition, giving you faster results at a lower cost.</p> <p>\ud83d\ude80 Register | \ud83d\udcd6 Docs | \ud83d\udcac Telegram</p> <p></p>"},{"location":"sponsors/#hyper-solutions","title":"Hyper Solutions","text":"<p>TLS fingerprinting alone isn't enough for modern bot protection. Hyper Solutions provides the missing piece - API endpoints that generate valid antibot tokens for:</p> <p>Akamai \u2022 DataDome \u2022 Kasada \u2022 Incapsula</p> <p>No browser automation. Just simple API calls that return the exact cookies and headers these systems require.</p> <p>\ud83d\ude80 Get Your API Key | \ud83d\udcd6 Docs | \ud83d\udcac Discord</p> <p></p>"},{"location":"sponsors/#capsolver","title":"CapSolver","text":"<p>CapSolver leverages AI-powered Auto Web Unblock to bypass Captchas effortlessly, providing fast, reliable, and cost-effective data access with seamless integration into Colly, Puppeteer, and Playwright\u2014use code <code>RNET</code> for a 6% bonus!</p>"},{"location":"sponsors/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Interested in sponsoring this project? Contact us or check out our sponsorship options.</p>"},{"location":"api/blocking/","title":"rnet.blocking","text":"<p>The blocking (synchronous) client provides the same functionality as the async client but with a synchronous API.</p>"},{"location":"api/blocking/#rnet.blocking","title":"rnet.blocking","text":""},{"location":"api/blocking/#rnet.blocking.Response","title":"Response","text":"<p>A blocking response from a request.</p> Source code in <code>rnet/blocking.py</code> <pre><code>class Response:\n    r\"\"\"\n    A blocking response from a request.\n    \"\"\"\n\n    url: str\n    r\"\"\"\n    Get the URL of the response.\n    \"\"\"\n\n    status: StatusCode\n    r\"\"\"\n    Get the status code of the response.\n    \"\"\"\n\n    version: Version\n    r\"\"\"\n    Get the HTTP version of the response.\n    \"\"\"\n\n    headers: HeaderMap\n    r\"\"\"\n    Get the headers of the response.\n    \"\"\"\n\n    cookies: Sequence[Cookie]\n    r\"\"\"\n    Get the cookies of the response.\n    \"\"\"\n\n    content_length: int | None\n    r\"\"\"\n    Get the content length of the response.\n    \"\"\"\n\n    remote_addr: SocketAddr | None\n    r\"\"\"\n    Get the remote address of the response.\n    \"\"\"\n\n    local_addr: SocketAddr | None\n    r\"\"\"\n    Get the local address of the response.\n    \"\"\"\n\n    history: Sequence[History]\n    r\"\"\"\n    Get the redirect history of the Response.\n    \"\"\"\n\n    tls_info: TlsInfo | None\n    r\"\"\"\n    Get the TLS information of the response.\n    \"\"\"\n\n    def raise_for_status(self) -&gt; None:\n        r\"\"\"\n        Turn a response into an error if the server returned an error.\n        \"\"\"\n\n    def stream(self) -&gt; Streamer:\n        r\"\"\"\n        Get the response into a `Streamer` of `bytes` from the body.\n        \"\"\"\n        ...\n\n    def text(self) -&gt; str:\n        r\"\"\"\n        Get the text content of the response.\n        \"\"\"\n        ...\n\n    def text_with_charset(self, encoding: str) -&gt; str:\n        r\"\"\"\n        Get the full response text given a specific encoding.\n        \"\"\"\n        ...\n\n    def json(self) -&gt; Any:\n        r\"\"\"\n        Get the JSON content of the response.\n        \"\"\"\n\n    def bytes(self) -&gt; bytes:\n        r\"\"\"\n        Get the bytes content of the response.\n        \"\"\"\n        ...\n\n    def close(self) -&gt; None:\n        r\"\"\"\n        Close the response connection.\n        \"\"\"\n\n    def __enter__(self) -&gt; \"Response\": ...\n    def __exit__(self, _exc_type: Any, _exc_value: Any, _traceback: Any) -&gt; None: ...\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url\n</code></pre> <p>Get the URL of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>Get the status code of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version\n</code></pre> <p>Get the HTTP version of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>Get the headers of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.cookies","title":"cookies  <code>instance-attribute</code>","text":"<pre><code>cookies\n</code></pre> <p>Get the cookies of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.content_length","title":"content_length  <code>instance-attribute</code>","text":"<pre><code>content_length\n</code></pre> <p>Get the content length of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.remote_addr","title":"remote_addr  <code>instance-attribute</code>","text":"<pre><code>remote_addr\n</code></pre> <p>Get the remote address of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.local_addr","title":"local_addr  <code>instance-attribute</code>","text":"<pre><code>local_addr\n</code></pre> <p>Get the local address of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.history","title":"history  <code>instance-attribute</code>","text":"<pre><code>history\n</code></pre> <p>Get the redirect history of the Response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.tls_info","title":"tls_info  <code>instance-attribute</code>","text":"<pre><code>tls_info\n</code></pre> <p>Get the TLS information of the response.</p>"},{"location":"api/blocking/#rnet.blocking.Response.raise_for_status","title":"raise_for_status","text":"<pre><code>raise_for_status()\n</code></pre> <p>Turn a response into an error if the server returned an error.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def raise_for_status(self) -&gt; None:\n    r\"\"\"\n    Turn a response into an error if the server returned an error.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.stream","title":"stream","text":"<pre><code>stream()\n</code></pre> <p>Get the response into a <code>Streamer</code> of <code>bytes</code> from the body.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def stream(self) -&gt; Streamer:\n    r\"\"\"\n    Get the response into a `Streamer` of `bytes` from the body.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.text","title":"text","text":"<pre><code>text()\n</code></pre> <p>Get the text content of the response.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def text(self) -&gt; str:\n    r\"\"\"\n    Get the text content of the response.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.text_with_charset","title":"text_with_charset","text":"<pre><code>text_with_charset(encoding)\n</code></pre> <p>Get the full response text given a specific encoding.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def text_with_charset(self, encoding: str) -&gt; str:\n    r\"\"\"\n    Get the full response text given a specific encoding.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.json","title":"json","text":"<pre><code>json()\n</code></pre> <p>Get the JSON content of the response.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def json(self) -&gt; Any:\n    r\"\"\"\n    Get the JSON content of the response.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.bytes","title":"bytes","text":"<pre><code>bytes()\n</code></pre> <p>Get the bytes content of the response.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def bytes(self) -&gt; bytes:\n    r\"\"\"\n    Get the bytes content of the response.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Response.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the response connection.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def close(self) -&gt; None:\n    r\"\"\"\n    Close the response connection.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.WebSocket","title":"WebSocket","text":"<p>A blocking WebSocket response.</p> Source code in <code>rnet/blocking.py</code> <pre><code>class WebSocket:\n    r\"\"\"\n    A blocking WebSocket response.\n    \"\"\"\n\n    status: StatusCode\n    r\"\"\"\n    Get the status code of the response.\n    \"\"\"\n\n    version: Version\n    r\"\"\"\n    Get the HTTP version of the response.\n    \"\"\"\n\n    headers: HeaderMap\n    r\"\"\"\n    Get the headers of the response.\n    \"\"\"\n\n    cookies: Sequence[Cookie]\n    r\"\"\"\n    Get the cookies of the response.\n    \"\"\"\n\n    remote_addr: SocketAddr | None\n    r\"\"\"\n    Get the remote address of the response.\n    \"\"\"\n\n    protocol: str | None\n    r\"\"\"\n    Get the WebSocket protocol.\n    \"\"\"\n\n    def recv(self, timeout: datetime.timedelta | None = None) -&gt; Message | None:\n        r\"\"\"\n        Receive a message from the WebSocket.\n        \"\"\"\n\n    def send(self, message: Message) -&gt; None:\n        r\"\"\"\n        Send a message to the WebSocket.\n\n        # Arguments\n\n        * `message` - The message to send.\n        \"\"\"\n\n    def send_all(self, messages: Sequence[Message]) -&gt; None:\n        r\"\"\"\n        Send multiple messages to the WebSocket.\n\n        # Arguments\n\n        * `messages` - The sequence of messages to send.\n        \"\"\"\n\n    def close(\n        self,\n        code: int | None = None,\n        reason: str | None = None,\n    ) -&gt; None:\n        r\"\"\"\n        Close the WebSocket connection.\n\n        # Arguments\n\n        * `code` - An optional close code.\n        * `reason` - An optional reason for closing.\n        \"\"\"\n\n    def __enter__(self) -&gt; \"WebSocket\": ...\n    def __exit__(self, _exc_type: Any, _exc_value: Any, _traceback: Any) -&gt; None: ...\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.WebSocket.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>Get the status code of the response.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version\n</code></pre> <p>Get the HTTP version of the response.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>Get the headers of the response.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.cookies","title":"cookies  <code>instance-attribute</code>","text":"<pre><code>cookies\n</code></pre> <p>Get the cookies of the response.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.remote_addr","title":"remote_addr  <code>instance-attribute</code>","text":"<pre><code>remote_addr\n</code></pre> <p>Get the remote address of the response.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol\n</code></pre> <p>Get the WebSocket protocol.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.recv","title":"recv","text":"<pre><code>recv(timeout=None)\n</code></pre> <p>Receive a message from the WebSocket.</p> Source code in <code>rnet/blocking.py</code> <pre><code>def recv(self, timeout: datetime.timedelta | None = None) -&gt; Message | None:\n    r\"\"\"\n    Receive a message from the WebSocket.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.WebSocket.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message to the WebSocket.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.send--arguments","title":"Arguments","text":"<ul> <li><code>message</code> - The message to send.</li> </ul> Source code in <code>rnet/blocking.py</code> <pre><code>def send(self, message: Message) -&gt; None:\n    r\"\"\"\n    Send a message to the WebSocket.\n\n    # Arguments\n\n    * `message` - The message to send.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.WebSocket.send_all","title":"send_all","text":"<pre><code>send_all(messages)\n</code></pre> <p>Send multiple messages to the WebSocket.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.send_all--arguments","title":"Arguments","text":"<ul> <li><code>messages</code> - The sequence of messages to send.</li> </ul> Source code in <code>rnet/blocking.py</code> <pre><code>def send_all(self, messages: Sequence[Message]) -&gt; None:\n    r\"\"\"\n    Send multiple messages to the WebSocket.\n\n    # Arguments\n\n    * `messages` - The sequence of messages to send.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.WebSocket.close","title":"close","text":"<pre><code>close(code=None, reason=None)\n</code></pre> <p>Close the WebSocket connection.</p>"},{"location":"api/blocking/#rnet.blocking.WebSocket.close--arguments","title":"Arguments","text":"<ul> <li><code>code</code> - An optional close code.</li> <li><code>reason</code> - An optional reason for closing.</li> </ul> Source code in <code>rnet/blocking.py</code> <pre><code>def close(\n    self,\n    code: int | None = None,\n    reason: str | None = None,\n) -&gt; None:\n    r\"\"\"\n    Close the WebSocket connection.\n\n    # Arguments\n\n    * `code` - An optional close code.\n    * `reason` - An optional reason for closing.\n    \"\"\"\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client","title":"Client","text":"<p>A blocking client for making HTTP requests.</p> Source code in <code>rnet/blocking.py</code> <pre><code>class Client:\n    r\"\"\"\n    A blocking client for making HTTP requests.\n    \"\"\"\n\n    cookie_jar: Jar | None\n    r\"\"\"\n    Get the cookie jar used by this client (if enabled/configured).\n\n    Returns:\n        - The provided `Jar` if the client was constructed with `cookie_provider=...`\n        - The auto-created `Jar` if the client was constructed with `cookie_store=True`\n    \"\"\"\n\n    def __init__(\n        self,\n        **kwargs: Unpack[ClientConfig],\n    ) -&gt; None:\n        r\"\"\"\n        Creates a new blocking Client instance.\n\n        # Examples\n\n        ```python\n        import asyncio\n        import rnet\n\n        client = rnet.blocking.Client(\n            user_agent=\"Mozilla/5.0\",\n            timeout=10,\n        )\n        response = client.get('https://httpbin.io/get')\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def request(\n        self,\n        method: Method,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given method and URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.request(Method.GET, \"https://httpbin.io/anything\")\n        ```\n        \"\"\"\n        ...\n\n    def websocket(self, url: str, **kwargs: Unpack[WebSocketRequest]) -&gt; \"WebSocket\":\n        r\"\"\"\n        Sends a WebSocket request.\n\n        # Examples\n\n        ```python\n        import rnet\n\n        client = rnet.blocking.Client()\n        ws = client.websocket(\"wss://echo.websocket.org\")\n        ws.send(rnet.Message.from_text(\"Hello, WebSocket!\"))\n        message = ws.recv()\n        print(\"Received:\", message.data)\n        ws.close()\n        ```\n        \"\"\"\n        ...\n\n    def trace(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.trace(\"https://httpbin.io/anything\")\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def options(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.options(\"https://httpbin.io/anything\")\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def head(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        def main():\n        client = rnet.blocking.Client()\n        response = client.head(\"https://httpbin.io/anything\")\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def delete(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.delete(\"https://httpbin.io/anything\")\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def patch(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.patch(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def put(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.put(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def post(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.post(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n\n    def get(\n        self,\n        url: str,\n        **kwargs: Unpack[Request],\n    ) -&gt; \"Response\":\n        r\"\"\"\n        Sends a request with the given URL.\n\n        # Examples\n\n        ```python\n        import rnet\n        from rnet import Method\n\n        client = rnet.blocking.Client()\n        response = client.get(\"https://httpbin.io/anything\")\n        print(response.text())\n        ```\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.cookie_jar","title":"cookie_jar  <code>instance-attribute</code>","text":"<pre><code>cookie_jar\n</code></pre> <p>Get the cookie jar used by this client (if enabled/configured).</p> <p>Returns:</p> Type Description <code>Jar | None</code> <ul> <li>The provided <code>Jar</code> if the client was constructed with <code>cookie_provider=...</code></li> </ul> <code>Jar | None</code> <ul> <li>The auto-created <code>Jar</code> if the client was constructed with <code>cookie_store=True</code></li> </ul>"},{"location":"api/blocking/#rnet.blocking.Client.__init__","title":"__init__","text":"<pre><code>__init__(**kwargs)\n</code></pre> <p>Creates a new blocking Client instance.</p>"},{"location":"api/blocking/#rnet.blocking.Client.__init__--examples","title":"Examples","text":"<pre><code>import asyncio\nimport rnet\n\nclient = rnet.blocking.Client(\n    user_agent=\"Mozilla/5.0\",\n    timeout=10,\n)\nresponse = client.get('https://httpbin.io/get')\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def __init__(\n    self,\n    **kwargs: Unpack[ClientConfig],\n) -&gt; None:\n    r\"\"\"\n    Creates a new blocking Client instance.\n\n    # Examples\n\n    ```python\n    import asyncio\n    import rnet\n\n    client = rnet.blocking.Client(\n        user_agent=\"Mozilla/5.0\",\n        timeout=10,\n    )\n    response = client.get('https://httpbin.io/get')\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.request","title":"request","text":"<pre><code>request(method, url, **kwargs)\n</code></pre> <p>Sends a request with the given method and URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.request--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.request(Method.GET, \"https://httpbin.io/anything\")\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def request(\n    self,\n    method: Method,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given method and URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.request(Method.GET, \"https://httpbin.io/anything\")\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.websocket","title":"websocket","text":"<pre><code>websocket(url, **kwargs)\n</code></pre> <p>Sends a WebSocket request.</p>"},{"location":"api/blocking/#rnet.blocking.Client.websocket--examples","title":"Examples","text":"<pre><code>import rnet\n\nclient = rnet.blocking.Client()\nws = client.websocket(\"wss://echo.websocket.org\")\nws.send(rnet.Message.from_text(\"Hello, WebSocket!\"))\nmessage = ws.recv()\nprint(\"Received:\", message.data)\nws.close()\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def websocket(self, url: str, **kwargs: Unpack[WebSocketRequest]) -&gt; \"WebSocket\":\n    r\"\"\"\n    Sends a WebSocket request.\n\n    # Examples\n\n    ```python\n    import rnet\n\n    client = rnet.blocking.Client()\n    ws = client.websocket(\"wss://echo.websocket.org\")\n    ws.send(rnet.Message.from_text(\"Hello, WebSocket!\"))\n    message = ws.recv()\n    print(\"Received:\", message.data)\n    ws.close()\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.trace","title":"trace","text":"<pre><code>trace(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.trace--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.trace(\"https://httpbin.io/anything\")\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def trace(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.trace(\"https://httpbin.io/anything\")\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.options","title":"options","text":"<pre><code>options(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.options--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.options(\"https://httpbin.io/anything\")\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def options(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.options(\"https://httpbin.io/anything\")\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.head","title":"head","text":"<pre><code>head(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.head--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\ndef main():\nclient = rnet.blocking.Client()\nresponse = client.head(\"https://httpbin.io/anything\")\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def head(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    def main():\n    client = rnet.blocking.Client()\n    response = client.head(\"https://httpbin.io/anything\")\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.delete","title":"delete","text":"<pre><code>delete(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.delete--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.delete(\"https://httpbin.io/anything\")\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def delete(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.delete(\"https://httpbin.io/anything\")\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.patch","title":"patch","text":"<pre><code>patch(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.patch--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.patch(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def patch(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.patch(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.put","title":"put","text":"<pre><code>put(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.put--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.put(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def put(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.put(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.post","title":"post","text":"<pre><code>post(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.post--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.post(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def post(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.post(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/blocking/#rnet.blocking.Client.get","title":"get","text":"<pre><code>get(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL.</p>"},{"location":"api/blocking/#rnet.blocking.Client.get--examples","title":"Examples","text":"<pre><code>import rnet\nfrom rnet import Method\n\nclient = rnet.blocking.Client()\nresponse = client.get(\"https://httpbin.io/anything\")\nprint(response.text())\n</code></pre> Source code in <code>rnet/blocking.py</code> <pre><code>def get(\n    self,\n    url: str,\n    **kwargs: Unpack[Request],\n) -&gt; \"Response\":\n    r\"\"\"\n    Sends a request with the given URL.\n\n    # Examples\n\n    ```python\n    import rnet\n    from rnet import Method\n\n    client = rnet.blocking.Client()\n    response = client.get(\"https://httpbin.io/anything\")\n    print(response.text())\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/","title":"rnet.cookie","text":"<p>Cookie management and storage for maintaining session state.</p>"},{"location":"api/cookie/#rnet.cookie","title":"rnet.cookie","text":"<p>HTTP Cookie Management</p> <p>This module provides classes for creating, managing, and storing HTTP cookies in a thread-safe manner. It includes support for all standard cookie attributes and provides a cookie jar for automatic cookie handling during HTTP requests.</p>"},{"location":"api/cookie/#rnet.cookie.SameSite","title":"SameSite","text":"<p>               Bases: <code>Enum</code></p> <p>The Cookie SameSite attribute.</p> Source code in <code>rnet/cookie.py</code> <pre><code>@final\nclass SameSite(Enum):\n    r\"\"\"\n    The Cookie SameSite attribute.\n    \"\"\"\n\n    Strict = auto()\n    Lax = auto()\n    Empty = auto()\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Cookie","title":"Cookie","text":"<p>A cookie.</p> Source code in <code>rnet/cookie.py</code> <pre><code>class Cookie:\n    r\"\"\"\n    A cookie.\n    \"\"\"\n\n    name: str\n    r\"\"\"\n    The name of the cookie.\n    \"\"\"\n    value: str\n    r\"\"\"\n    The value of the cookie.\n    \"\"\"\n    http_only: bool\n    r\"\"\"\n    Returns true if the 'HttpOnly' directive is enabled.\n    \"\"\"\n    secure: bool\n    r\"\"\"\n    Returns true if the 'Secure' directive is enabled.\n    \"\"\"\n    same_site_lax: bool\n    r\"\"\"\n    Returns true if  'SameSite' directive is 'Lax'.\n    \"\"\"\n    same_site_strict: bool\n    r\"\"\"\n    Returns true if  'SameSite' directive is 'Strict'.\n    \"\"\"\n    path: str | None\n    r\"\"\"\n    Returns the path directive of the cookie, if set.\n    \"\"\"\n    domain: str | None\n    r\"\"\"\n    Returns the domain directive of the cookie, if set.\n    \"\"\"\n    max_age: datetime.timedelta | None\n    r\"\"\"\n    Get the Max-Age information.\n    \"\"\"\n    expires: datetime.datetime | None\n    r\"\"\"\n    The cookie expiration time.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        value: str,\n        domain: str | None = None,\n        path: str | None = None,\n        max_age: datetime.timedelta | None = None,\n        expires: datetime.datetime | None = None,\n        http_only: bool | None = None,\n        secure: bool | None = None,\n        same_site: SameSite | None = None,\n    ) -&gt; None:\n        r\"\"\"\n        Create a new cookie.\n        \"\"\"\n        ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Cookie.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre> <p>The name of the cookie.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>The value of the cookie.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.http_only","title":"http_only  <code>instance-attribute</code>","text":"<pre><code>http_only\n</code></pre> <p>Returns true if the 'HttpOnly' directive is enabled.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.secure","title":"secure  <code>instance-attribute</code>","text":"<pre><code>secure\n</code></pre> <p>Returns true if the 'Secure' directive is enabled.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.same_site_lax","title":"same_site_lax  <code>instance-attribute</code>","text":"<pre><code>same_site_lax\n</code></pre> <p>Returns true if  'SameSite' directive is 'Lax'.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.same_site_strict","title":"same_site_strict  <code>instance-attribute</code>","text":"<pre><code>same_site_strict\n</code></pre> <p>Returns true if  'SameSite' directive is 'Strict'.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path\n</code></pre> <p>Returns the path directive of the cookie, if set.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.domain","title":"domain  <code>instance-attribute</code>","text":"<pre><code>domain\n</code></pre> <p>Returns the domain directive of the cookie, if set.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.max_age","title":"max_age  <code>instance-attribute</code>","text":"<pre><code>max_age\n</code></pre> <p>Get the Max-Age information.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.expires","title":"expires  <code>instance-attribute</code>","text":"<pre><code>expires\n</code></pre> <p>The cookie expiration time.</p>"},{"location":"api/cookie/#rnet.cookie.Cookie.__init__","title":"__init__","text":"<pre><code>__init__(name, value, domain=None, path=None, max_age=None, expires=None, http_only=None, secure=None, same_site=None)\n</code></pre> <p>Create a new cookie.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    value: str,\n    domain: str | None = None,\n    path: str | None = None,\n    max_age: datetime.timedelta | None = None,\n    expires: datetime.datetime | None = None,\n    http_only: bool | None = None,\n    secure: bool | None = None,\n    same_site: SameSite | None = None,\n) -&gt; None:\n    r\"\"\"\n    Create a new cookie.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar","title":"Jar","text":"<p>A thread-safe cookie jar for storing and managing HTTP cookies.</p> <p>This cookie jar can be safely shared across multiple threads and is used to automatically handle cookies during HTTP requests and responses.</p> <p>By default, cookie compression is enabled to reduce storage overhead. Use <code>uncompressed()</code> to create a variant without compression if needed.</p> Source code in <code>rnet/cookie.py</code> <pre><code>class Jar:\n    r\"\"\"\n    A thread-safe cookie jar for storing and managing HTTP cookies.\n\n    This cookie jar can be safely shared across multiple threads and is used\n    to automatically handle cookies during HTTP requests and responses.\n\n    By default, cookie compression is enabled to reduce storage overhead.\n    Use `uncompressed()` to create a variant without compression if needed.\n    \"\"\"\n\n    def __init__(self, compression: bool | None = None) -&gt; None:\n        r\"\"\"\n        Create a new cookie jar with compression enabled by default.\n        \"\"\"\n        ...\n\n    def compressed(self) -&gt; \"Jar\":\n        r\"\"\"\n        Clone this Jar, sharing storage but enabling compression.\n        \"\"\"\n        ...\n\n    def uncompressed(self) -&gt; \"Jar\":\n        r\"\"\"\n        Clone this Jar, sharing storage but disabling compression.\n        \"\"\"\n        ...\n\n    def get(self, name: str, url: str) -&gt; Cookie | None:\n        r\"\"\"\n        Get a cookie by name and URL.\n        \"\"\"\n        ...\n\n    def get_all(self) -&gt; Sequence[Cookie]:\n        r\"\"\"\n        Get all cookies.\n        \"\"\"\n        ...\n\n    def add(self, cookie: Cookie | str, url: str) -&gt; None:\n        r\"\"\"\n        Add a cookie or cookie string to this jar.\n        \"\"\"\n        ...\n\n    def remove(self, name: str, url: str) -&gt; None:\n        r\"\"\"\n        Remove a cookie from this jar by name and URL.\n        \"\"\"\n        ...\n\n    def clear(self) -&gt; None:\n        r\"\"\"\n        Clear all cookies in this jar.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.__init__","title":"__init__","text":"<pre><code>__init__(compression=None)\n</code></pre> <p>Create a new cookie jar with compression enabled by default.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def __init__(self, compression: bool | None = None) -&gt; None:\n    r\"\"\"\n    Create a new cookie jar with compression enabled by default.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.compressed","title":"compressed","text":"<pre><code>compressed()\n</code></pre> <p>Clone this Jar, sharing storage but enabling compression.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def compressed(self) -&gt; \"Jar\":\n    r\"\"\"\n    Clone this Jar, sharing storage but enabling compression.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.uncompressed","title":"uncompressed","text":"<pre><code>uncompressed()\n</code></pre> <p>Clone this Jar, sharing storage but disabling compression.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def uncompressed(self) -&gt; \"Jar\":\n    r\"\"\"\n    Clone this Jar, sharing storage but disabling compression.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.get","title":"get","text":"<pre><code>get(name, url)\n</code></pre> <p>Get a cookie by name and URL.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def get(self, name: str, url: str) -&gt; Cookie | None:\n    r\"\"\"\n    Get a cookie by name and URL.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.get_all","title":"get_all","text":"<pre><code>get_all()\n</code></pre> <p>Get all cookies.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def get_all(self) -&gt; Sequence[Cookie]:\n    r\"\"\"\n    Get all cookies.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.add","title":"add","text":"<pre><code>add(cookie, url)\n</code></pre> <p>Add a cookie or cookie string to this jar.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def add(self, cookie: Cookie | str, url: str) -&gt; None:\n    r\"\"\"\n    Add a cookie or cookie string to this jar.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.remove","title":"remove","text":"<pre><code>remove(name, url)\n</code></pre> <p>Remove a cookie from this jar by name and URL.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def remove(self, name: str, url: str) -&gt; None:\n    r\"\"\"\n    Remove a cookie from this jar by name and URL.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/cookie/#rnet.cookie.Jar.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear all cookies in this jar.</p> Source code in <code>rnet/cookie.py</code> <pre><code>def clear(self) -&gt; None:\n    r\"\"\"\n    Clear all cookies in this jar.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/core/","title":"rnet (Main Module)","text":"<p>The main <code>rnet</code> module contains core classes and types used throughout the library.</p>"},{"location":"api/core/#core-classes","title":"Core Classes","text":""},{"location":"api/core/#rnet.Client","title":"rnet.Client","text":"<p>A client for making HTTP requests.</p>"},{"location":"api/core/#rnet.Client.cookie_jar","title":"cookie_jar  <code>instance-attribute</code>","text":"<pre><code>cookie_jar\n</code></pre> <p>Get the cookie jar used by this client (if enabled/configured).</p> <p>Returns:</p> Type Description <code>Jar | None</code> <ul> <li>The provided <code>Jar</code> if the client was constructed with <code>cookie_provider=...</code></li> </ul> <code>Jar | None</code> <ul> <li>The auto-created <code>Jar</code> if the client was constructed with <code>cookie_store=True</code></li> </ul>"},{"location":"api/core/#rnet.Client.__init__","title":"__init__","text":"<pre><code>__init__(**kwargs)\n</code></pre> <p>Creates a new Client instance.</p> <p>Examples:</p> <pre><code>import asyncio\nimport rnet\n\nasync def main():\n    client = rnet.Client(\n        user_agent=\"Mozilla/5.0\",\n        timeout=10,\n    )\n    response = await client.get('https://httpbin.io/get')\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.request","title":"request  <code>async</code>","text":"<pre><code>request(method, url, **kwargs)\n</code></pre> <p>Sends a request with the given method and URL.</p>"},{"location":"api/core/#rnet.Client.request--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.request(Method.GET, \"https://httpbin.io/anything\")\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.websocket","title":"websocket  <code>async</code>","text":"<pre><code>websocket(url, **kwargs)\n</code></pre> <p>Sends a WebSocket request.</p>"},{"location":"api/core/#rnet.Client.websocket--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\n\nasync def main():\n    client = rnet.Client()\n    ws = await client.websocket(\"wss://echo.websocket.org\")\n    await ws.send(rnet.Message.from_text(\"Hello, WebSocket!\"))\n    message = await ws.recv()\n    print(\"Received:\", message.data)\n    await ws.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.trace","title":"trace  <code>async</code>","text":"<pre><code>trace(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.trace--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.trace(\"https://httpbin.io/anything\")\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.options","title":"options  <code>async</code>","text":"<pre><code>options(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.options--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.options(\"https://httpbin.io/anything\")\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.patch","title":"patch  <code>async</code>","text":"<pre><code>patch(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.patch--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.patch(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.delete--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.delete(\"https://httpbin.io/anything\")\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.put","title":"put  <code>async</code>","text":"<pre><code>put(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.put--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.put(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.post","title":"post  <code>async</code>","text":"<pre><code>post(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.post--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.post(\"https://httpbin.io/anything\", json={\"key\": \"value\"})\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.head","title":"head  <code>async</code>","text":"<pre><code>head(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.head--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.head(\"https://httpbin.io/anything\")\n    print(response.status)\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Client.get","title":"get  <code>async</code>","text":"<pre><code>get(url, **kwargs)\n</code></pre> <p>Sends a request with the given URL</p>"},{"location":"api/core/#rnet.Client.get--examples","title":"Examples","text":"<pre><code>import rnet\nimport asyncio\nfrom rnet import Method\n\nasync def main():\n    client = rnet.Client()\n    response = await client.get(\"https://httpbin.io/anything\")\n    print(await response.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Response","title":"rnet.Response","text":"<p>A response from a request.</p>"},{"location":"api/core/#rnet.Response--examples","title":"Examples","text":"<pre><code>import asyncio\nimport rnet\n\nasync def main():\n    response = await rnet.get(\"https://www.rust-lang.org\")\n    print(\"Status Code: \", response.status)\n    print(\"Version: \", response.version)\n    print(\"Response URL: \", response.url)\n    print(\"Headers: \", response.headers)\n    print(\"Content-Length: \", response.content_length)\n    print(\"Encoding: \", response.encoding)\n    print(\"Remote Address: \", response.remote_addr)\n\n    text_content = await response.text()\n    print(\"Text: \", text_content)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/core/#rnet.Response.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url\n</code></pre> <p>Get the URL of the response.</p>"},{"location":"api/core/#rnet.Response.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>Get the status code of the response.</p>"},{"location":"api/core/#rnet.Response.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version\n</code></pre> <p>Get the HTTP version of the response.</p>"},{"location":"api/core/#rnet.Response.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>Get the headers of the response.</p>"},{"location":"api/core/#rnet.Response.cookies","title":"cookies  <code>instance-attribute</code>","text":"<pre><code>cookies\n</code></pre> <p>Get the cookies of the response.</p>"},{"location":"api/core/#rnet.Response.content_length","title":"content_length  <code>instance-attribute</code>","text":"<pre><code>content_length\n</code></pre> <p>Get the content length of the response.</p>"},{"location":"api/core/#rnet.Response.remote_addr","title":"remote_addr  <code>instance-attribute</code>","text":"<pre><code>remote_addr\n</code></pre> <p>Get the remote address of the response.</p>"},{"location":"api/core/#rnet.Response.local_addr","title":"local_addr  <code>instance-attribute</code>","text":"<pre><code>local_addr\n</code></pre> <p>Get the local address of the response.</p>"},{"location":"api/core/#rnet.Response.history","title":"history  <code>instance-attribute</code>","text":"<pre><code>history\n</code></pre> <p>Get the redirect history of the Response.</p>"},{"location":"api/core/#rnet.Response.tls_info","title":"tls_info  <code>instance-attribute</code>","text":"<pre><code>tls_info\n</code></pre> <p>Get the TLS information of the response.</p>"},{"location":"api/core/#rnet.Response.raise_for_status","title":"raise_for_status","text":"<pre><code>raise_for_status()\n</code></pre> <p>Turn a response into an error if the server returned an error.</p>"},{"location":"api/core/#rnet.Response.stream","title":"stream","text":"<pre><code>stream()\n</code></pre> <p>Get the response into a <code>Streamer</code> of <code>bytes</code> from the body.</p>"},{"location":"api/core/#rnet.Response.text","title":"text  <code>async</code>","text":"<pre><code>text()\n</code></pre> <p>Get the text content of the response.</p>"},{"location":"api/core/#rnet.Response.text_with_charset","title":"text_with_charset  <code>async</code>","text":"<pre><code>text_with_charset(encoding)\n</code></pre> <p>Get the full response text given a specific encoding.</p>"},{"location":"api/core/#rnet.Response.json","title":"json  <code>async</code>","text":"<pre><code>json()\n</code></pre> <p>Get the JSON content of the response.</p>"},{"location":"api/core/#rnet.Response.bytes","title":"bytes  <code>async</code>","text":"<pre><code>bytes()\n</code></pre> <p>Get the bytes content of the response.</p>"},{"location":"api/core/#rnet.Response.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the response connection.</p>"},{"location":"api/core/#http-types","title":"HTTP Types","text":""},{"location":"api/core/#rnet.Method","title":"rnet.Method","text":"<p>               Bases: <code>Enum</code></p> <p>An HTTP method.</p>"},{"location":"api/core/#rnet.Version","title":"rnet.Version","text":"<p>               Bases: <code>Enum</code></p> <p>An HTTP version.</p>"},{"location":"api/core/#rnet.StatusCode","title":"rnet.StatusCode","text":"<p>HTTP status code.</p>"},{"location":"api/core/#rnet.StatusCode.as_int","title":"as_int","text":"<pre><code>as_int()\n</code></pre> <p>Return the status code as an integer.</p>"},{"location":"api/core/#rnet.StatusCode.is_informational","title":"is_informational","text":"<pre><code>is_informational()\n</code></pre> <p>Check if status is within 100-199.</p>"},{"location":"api/core/#rnet.StatusCode.is_success","title":"is_success","text":"<pre><code>is_success()\n</code></pre> <p>Check if status is within 200-299.</p>"},{"location":"api/core/#rnet.StatusCode.is_redirection","title":"is_redirection","text":"<pre><code>is_redirection()\n</code></pre> <p>Check if status is within 300-399.</p>"},{"location":"api/core/#rnet.StatusCode.is_client_error","title":"is_client_error","text":"<pre><code>is_client_error()\n</code></pre> <p>Check if status is within 400-499.</p>"},{"location":"api/core/#rnet.StatusCode.is_server_error","title":"is_server_error","text":"<pre><code>is_server_error()\n</code></pre> <p>Check if status is within 500-599.</p>"},{"location":"api/core/#rnet.StatusCode.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre>"},{"location":"api/core/#rnet.StatusCode.__richcmp__","title":"__richcmp__","text":"<pre><code>__richcmp__(other, op)\n</code></pre>"},{"location":"api/core/#request-types","title":"Request Types","text":""},{"location":"api/core/#rnet.Request","title":"rnet.Request","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"api/core/#rnet.Request.emulation","title":"emulation  <code>instance-attribute</code>","text":"<pre><code>emulation\n</code></pre> <p>The Emulation settings for the request.</p>"},{"location":"api/core/#rnet.Request.proxy","title":"proxy  <code>instance-attribute</code>","text":"<pre><code>proxy\n</code></pre> <p>The proxy to use for the request.</p>"},{"location":"api/core/#rnet.Request.local_address","title":"local_address  <code>instance-attribute</code>","text":"<pre><code>local_address\n</code></pre> <p>Bind to a local IP Address.</p>"},{"location":"api/core/#rnet.Request.local_addresses","title":"local_addresses  <code>instance-attribute</code>","text":"<pre><code>local_addresses\n</code></pre> <p>Bind to dual-stack local IP Addresses.</p>"},{"location":"api/core/#rnet.Request.interface","title":"interface  <code>instance-attribute</code>","text":"<pre><code>interface\n</code></pre> <p>Bind to an interface by SO_BINDTODEVICE.</p>"},{"location":"api/core/#rnet.Request.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout\n</code></pre> <p>The timeout to use for the request.</p>"},{"location":"api/core/#rnet.Request.read_timeout","title":"read_timeout  <code>instance-attribute</code>","text":"<pre><code>read_timeout\n</code></pre> <p>The read timeout to use for the request.</p>"},{"location":"api/core/#rnet.Request.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version\n</code></pre> <p>The HTTP version to use for the request.</p>"},{"location":"api/core/#rnet.Request.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>The headers to use for the request.</p>"},{"location":"api/core/#rnet.Request.orig_headers","title":"orig_headers  <code>instance-attribute</code>","text":"<pre><code>orig_headers\n</code></pre> <p>The original headers to use for the request.</p>"},{"location":"api/core/#rnet.Request.default_headers","title":"default_headers  <code>instance-attribute</code>","text":"<pre><code>default_headers\n</code></pre> <p>The option enables default headers.</p>"},{"location":"api/core/#rnet.Request.cookies","title":"cookies  <code>instance-attribute</code>","text":"<pre><code>cookies\n</code></pre> <p>The cookies to use for the request.</p>"},{"location":"api/core/#rnet.Request.redirect","title":"redirect  <code>instance-attribute</code>","text":"<pre><code>redirect\n</code></pre> <p>The redirect policy.</p>"},{"location":"api/core/#rnet.Request.cookie_provider","title":"cookie_provider  <code>instance-attribute</code>","text":"<pre><code>cookie_provider\n</code></pre> <p>Set cookie provider for the request.</p>"},{"location":"api/core/#rnet.Request.gzip","title":"gzip  <code>instance-attribute</code>","text":"<pre><code>gzip\n</code></pre> <p>Sets gzip as an accepted encoding.</p>"},{"location":"api/core/#rnet.Request.brotli","title":"brotli  <code>instance-attribute</code>","text":"<pre><code>brotli\n</code></pre> <p>Sets brotli as an accepted encoding.</p>"},{"location":"api/core/#rnet.Request.deflate","title":"deflate  <code>instance-attribute</code>","text":"<pre><code>deflate\n</code></pre> <p>Sets deflate as an accepted encoding.</p>"},{"location":"api/core/#rnet.Request.zstd","title":"zstd  <code>instance-attribute</code>","text":"<pre><code>zstd\n</code></pre> <p>Sets zstd as an accepted encoding.</p>"},{"location":"api/core/#rnet.Request.auth","title":"auth  <code>instance-attribute</code>","text":"<pre><code>auth\n</code></pre> <p>The authentication to use for the request.</p>"},{"location":"api/core/#rnet.Request.bearer_auth","title":"bearer_auth  <code>instance-attribute</code>","text":"<pre><code>bearer_auth\n</code></pre> <p>The bearer authentication to use for the request.</p>"},{"location":"api/core/#rnet.Request.basic_auth","title":"basic_auth  <code>instance-attribute</code>","text":"<pre><code>basic_auth\n</code></pre> <p>The basic authentication to use for the request.</p>"},{"location":"api/core/#rnet.Request.query","title":"query  <code>instance-attribute</code>","text":"<pre><code>query\n</code></pre> <p>The query parameters to use for the request.</p>"},{"location":"api/core/#rnet.Request.form","title":"form  <code>instance-attribute</code>","text":"<pre><code>form\n</code></pre> <p>The form parameters to use for the request.</p>"},{"location":"api/core/#rnet.Request.json","title":"json  <code>instance-attribute</code>","text":"<pre><code>json\n</code></pre> <p>The JSON body to use for the request.</p>"},{"location":"api/core/#rnet.Request.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body\n</code></pre> <p>The body to use for the request.</p>"},{"location":"api/core/#rnet.Request.multipart","title":"multipart  <code>instance-attribute</code>","text":"<pre><code>multipart\n</code></pre> <p>The multipart form to use for the request.</p>"},{"location":"api/core/#rnet.Multipart","title":"rnet.Multipart","text":"<p>A multipart form for a request.</p>"},{"location":"api/core/#rnet.Multipart.__init__","title":"__init__","text":"<pre><code>__init__(*parts)\n</code></pre> <p>Creates a new multipart form.</p>"},{"location":"api/core/#rnet.Part","title":"rnet.Part","text":"<p>A part of a multipart form.</p>"},{"location":"api/core/#rnet.Part.__init__","title":"__init__","text":"<pre><code>__init__(name, value, filename=None, mime=None, length=None, headers=None)\n</code></pre> <p>Creates a new part.</p>"},{"location":"api/core/#rnet.Part.__init__--arguments","title":"Arguments","text":"<ul> <li><code>name</code> - The name of the part.</li> <li><code>value</code> - The value of the part, either text, bytes, a file path, or a async or sync stream.</li> <li><code>filename</code> - The filename of the part.</li> <li><code>mime</code> - The MIME type of the part.</li> <li><code>length</code> - The length of the part when value is a stream (e.g., for file uploads).</li> <li><code>headers</code> - The custom headers for the part.</li> </ul>"},{"location":"api/core/#websocket","title":"WebSocket","text":""},{"location":"api/core/#rnet.WebSocket","title":"rnet.WebSocket","text":"<p>A WebSocket response.</p>"},{"location":"api/core/#rnet.WebSocket.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>Get the status code of the response.</p>"},{"location":"api/core/#rnet.WebSocket.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version\n</code></pre> <p>Get the HTTP version of the response.</p>"},{"location":"api/core/#rnet.WebSocket.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>Get the headers of the response.</p>"},{"location":"api/core/#rnet.WebSocket.cookies","title":"cookies  <code>instance-attribute</code>","text":"<pre><code>cookies\n</code></pre> <p>Get the cookies of the response.</p>"},{"location":"api/core/#rnet.WebSocket.remote_addr","title":"remote_addr  <code>instance-attribute</code>","text":"<pre><code>remote_addr\n</code></pre> <p>Get the remote address of the response.</p>"},{"location":"api/core/#rnet.WebSocket.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol\n</code></pre> <p>Get the WebSocket protocol.</p>"},{"location":"api/core/#rnet.WebSocket.recv","title":"recv  <code>async</code>","text":"<pre><code>recv(timeout=None)\n</code></pre> <p>Receive a message from the WebSocket.</p>"},{"location":"api/core/#rnet.WebSocket.send","title":"send  <code>async</code>","text":"<pre><code>send(message)\n</code></pre> <p>Send a message to the WebSocket.</p>"},{"location":"api/core/#rnet.WebSocket.send_all","title":"send_all  <code>async</code>","text":"<pre><code>send_all(messages)\n</code></pre> <p>Send multiple messages to the WebSocket.</p>"},{"location":"api/core/#rnet.WebSocket.close","title":"close  <code>async</code>","text":"<pre><code>close(code=None, reason=None)\n</code></pre> <p>Close the WebSocket connection.</p>"},{"location":"api/core/#rnet.WebSocketRequest","title":"rnet.WebSocketRequest","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"api/core/#rnet.WebSocketRequest.emulation","title":"emulation  <code>instance-attribute</code>","text":"<pre><code>emulation\n</code></pre> <p>The Emulation settings for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.proxy","title":"proxy  <code>instance-attribute</code>","text":"<pre><code>proxy\n</code></pre> <p>The proxy to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.local_address","title":"local_address  <code>instance-attribute</code>","text":"<pre><code>local_address\n</code></pre> <p>Bind to a local IP Address.</p>"},{"location":"api/core/#rnet.WebSocketRequest.local_addresses","title":"local_addresses  <code>instance-attribute</code>","text":"<pre><code>local_addresses\n</code></pre> <p>Bind to dual-stack local IP Addresses.</p>"},{"location":"api/core/#rnet.WebSocketRequest.interface","title":"interface  <code>instance-attribute</code>","text":"<pre><code>interface\n</code></pre> <p>Bind to an interface by SO_BINDTODEVICE.</p>"},{"location":"api/core/#rnet.WebSocketRequest.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>The headers to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.orig_headers","title":"orig_headers  <code>instance-attribute</code>","text":"<pre><code>orig_headers\n</code></pre> <p>The original headers to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.default_headers","title":"default_headers  <code>instance-attribute</code>","text":"<pre><code>default_headers\n</code></pre> <p>The option enables default headers.</p>"},{"location":"api/core/#rnet.WebSocketRequest.cookies","title":"cookies  <code>instance-attribute</code>","text":"<pre><code>cookies\n</code></pre> <p>The cookies to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.protocols","title":"protocols  <code>instance-attribute</code>","text":"<pre><code>protocols\n</code></pre> <p>The protocols to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.force_http2","title":"force_http2  <code>instance-attribute</code>","text":"<pre><code>force_http2\n</code></pre> <p>Whether to use HTTP/2 for the websocket.</p>"},{"location":"api/core/#rnet.WebSocketRequest.auth","title":"auth  <code>instance-attribute</code>","text":"<pre><code>auth\n</code></pre> <p>The authentication to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.bearer_auth","title":"bearer_auth  <code>instance-attribute</code>","text":"<pre><code>bearer_auth\n</code></pre> <p>The bearer authentication to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.basic_auth","title":"basic_auth  <code>instance-attribute</code>","text":"<pre><code>basic_auth\n</code></pre> <p>The basic authentication to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.query","title":"query  <code>instance-attribute</code>","text":"<pre><code>query\n</code></pre> <p>The query parameters to use for the request.</p>"},{"location":"api/core/#rnet.WebSocketRequest.read_buffer_size","title":"read_buffer_size  <code>instance-attribute</code>","text":"<pre><code>read_buffer_size\n</code></pre> <p>Read buffer capacity. This buffer is eagerly allocated and used for receiving messages.</p> <p>For high read load scenarios a larger buffer, e.g. 128 KiB, improves performance.</p> <p>For scenarios where you expect a lot of connections and don't need high read load performance a smaller buffer, e.g. 4 KiB, would be appropriate to lower total memory usage.</p> <p>The default value is 128 KiB.</p>"},{"location":"api/core/#rnet.WebSocketRequest.write_buffer_size","title":"write_buffer_size  <code>instance-attribute</code>","text":"<pre><code>write_buffer_size\n</code></pre> <p>The target minimum size of the write buffer to reach before writing the data to the underlying stream. The default value is 128 KiB.</p> <p>If set to 0 each message will be eagerly written to the underlying stream. It is often more optimal to allow them to buffer a little, hence the default value.</p> <p>Note: flush() will always fully write the buffer regardless.</p>"},{"location":"api/core/#rnet.WebSocketRequest.max_write_buffer_size","title":"max_write_buffer_size  <code>instance-attribute</code>","text":"<pre><code>max_write_buffer_size\n</code></pre> <p>The max size of the write buffer in bytes. Setting this can provide backpressure in the case the write buffer is filling up due to write errors. The default value is unlimited.</p> <p>Note: The write buffer only builds up past write_buffer_size when writes to the underlying stream are failing. So the write buffer can not fill up if you are not observing write errors even if not flushing.</p> <p>Note: Should always be at least write_buffer_size + 1 message and probably a little more depending on error handling strategy.</p>"},{"location":"api/core/#rnet.WebSocketRequest.max_message_size","title":"max_message_size  <code>instance-attribute</code>","text":"<pre><code>max_message_size\n</code></pre> <p>The maximum size of an incoming message. None means no size limit. The default value is 64 MiB which should be reasonably big for all normal use-cases but small enough to prevent memory eating by a malicious user.</p>"},{"location":"api/core/#rnet.WebSocketRequest.max_frame_size","title":"max_frame_size  <code>instance-attribute</code>","text":"<pre><code>max_frame_size\n</code></pre> <p>The maximum size of a single incoming message frame. None means no size limit. The limit is for frame payload NOT including the frame header. The default value is 16 MiB which should be reasonably big for all normal use-cases but small enough to prevent memory eating by a malicious user.</p>"},{"location":"api/core/#rnet.WebSocketRequest.accept_unmasked_frames","title":"accept_unmasked_frames  <code>instance-attribute</code>","text":"<pre><code>accept_unmasked_frames\n</code></pre> <p>When set to True, the server will accept and handle unmasked frames from the client. According to RFC 6455, the server must close the connection to the client in such cases, however it seems like there are some popular libraries that are sending unmasked frames, ignoring the RFC. By default this option is set to False, i.e. according to RFC6455.</p>"},{"location":"api/core/#rnet.Message","title":"rnet.Message","text":"<p>A WebSocket message.</p>"},{"location":"api/core/#rnet.Message.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>Returns the data of the message as bytes.</p>"},{"location":"api/core/#rnet.Message.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text\n</code></pre> <p>Returns the text content of the message if it is a text message.</p>"},{"location":"api/core/#rnet.Message.binary","title":"binary  <code>instance-attribute</code>","text":"<pre><code>binary\n</code></pre> <p>Returns the binary data of the message if it is a binary message.</p>"},{"location":"api/core/#rnet.Message.ping","title":"ping  <code>instance-attribute</code>","text":"<pre><code>ping\n</code></pre> <p>Returns the ping data of the message if it is a ping message.</p>"},{"location":"api/core/#rnet.Message.pong","title":"pong  <code>instance-attribute</code>","text":"<pre><code>pong\n</code></pre> <p>Returns the pong data of the message if it is a pong message.</p>"},{"location":"api/core/#rnet.Message.close","title":"close  <code>instance-attribute</code>","text":"<pre><code>close\n</code></pre> <p>Returns the close code and reason of the message if it is a close message.</p>"},{"location":"api/core/#rnet.Message.text_from_json","title":"text_from_json  <code>staticmethod</code>","text":"<pre><code>text_from_json(json)\n</code></pre> <p>Creates a new text message from the JSON representation.</p>"},{"location":"api/core/#rnet.Message.text_from_json--arguments","title":"Arguments","text":"<ul> <li><code>json</code> - The JSON representation of the message.</li> </ul>"},{"location":"api/core/#rnet.Message.binary_from_json","title":"binary_from_json  <code>staticmethod</code>","text":"<pre><code>binary_from_json(json)\n</code></pre> <p>Creates a new binary message from the JSON representation.</p>"},{"location":"api/core/#rnet.Message.binary_from_json--arguments","title":"Arguments","text":"<ul> <li><code>json</code> - The JSON representation of the message.</li> </ul>"},{"location":"api/core/#rnet.Message.from_text","title":"from_text  <code>staticmethod</code>","text":"<pre><code>from_text(text)\n</code></pre> <p>Creates a new text message.</p>"},{"location":"api/core/#rnet.Message.from_text--arguments","title":"Arguments","text":"<ul> <li><code>text</code> - The text content of the message.</li> </ul>"},{"location":"api/core/#rnet.Message.from_binary","title":"from_binary  <code>staticmethod</code>","text":"<pre><code>from_binary(data)\n</code></pre> <p>Creates a new binary message.</p>"},{"location":"api/core/#rnet.Message.from_binary--arguments","title":"Arguments","text":"<ul> <li><code>data</code> - The binary data of the message.</li> </ul>"},{"location":"api/core/#rnet.Message.from_ping","title":"from_ping  <code>staticmethod</code>","text":"<pre><code>from_ping(data)\n</code></pre> <p>Creates a new ping message.</p>"},{"location":"api/core/#rnet.Message.from_ping--arguments","title":"Arguments","text":"<ul> <li><code>data</code> - The ping data of the message.</li> </ul>"},{"location":"api/core/#rnet.Message.from_pong","title":"from_pong  <code>staticmethod</code>","text":"<pre><code>from_pong(data)\n</code></pre> <p>Creates a new pong message.</p>"},{"location":"api/core/#rnet.Message.from_pong--arguments","title":"Arguments","text":"<ul> <li><code>data</code> - The pong data of the message.</li> </ul>"},{"location":"api/core/#rnet.Message.from_close","title":"from_close  <code>staticmethod</code>","text":"<pre><code>from_close(code, reason=None)\n</code></pre> <p>Creates a new close message.</p>"},{"location":"api/core/#rnet.Message.from_close--arguments","title":"Arguments","text":"<ul> <li><code>code</code> - The close code.</li> <li><code>reason</code> - An optional reason for closing.</li> </ul>"},{"location":"api/core/#rnet.Message.json","title":"json","text":"<pre><code>json()\n</code></pre> <p>Returns the JSON representation of the message.</p>"},{"location":"api/core/#streaming","title":"Streaming","text":""},{"location":"api/core/#rnet.Streamer","title":"rnet.Streamer","text":"<p>A stream response. An asynchronous iterator yielding data chunks (bytes) or HTTP trailers (HeaderMap) from the response stream. Used to stream response content and receive HTTP trailers if present. Implemented in the <code>stream</code> method of the <code>Response</code> class. Can be used in an asynchronous for loop in Python.</p> <p>When streaming a response, each iteration yields either a bytes object (for body data) or a HeaderMap (for HTTP trailers, if the server sends them). This allows you to access HTTP/1.1 or HTTP/2 trailers in addition to the main body.</p>"},{"location":"api/core/#rnet.Streamer--examples","title":"Examples","text":"<pre><code>import asyncio\nimport rnet\nfrom rnet import Method, Emulation, HeaderMap\n\nasync def main():\n    resp = await rnet.get(\"https://example.com/stream-with-trailers\")\n    async with resp.stream() as streamer:\n        async for chunk in streamer:\n            if isinstance(chunk, bytes):\n                print(\"Chunk: \", chunk)\n            elif isinstance(chunk, HeaderMap):\n                print(\"Trailers: \", chunk)\n            await asyncio.sleep(0.1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/core/#network-types","title":"Network Types","text":""},{"location":"api/core/#rnet.SocketAddr","title":"rnet.SocketAddr","text":"<p>A IP socket address.</p>"},{"location":"api/core/#rnet.SocketAddr.ip","title":"ip","text":"<pre><code>ip()\n</code></pre> <p>Returns the IP address of the socket address.</p>"},{"location":"api/core/#rnet.SocketAddr.port","title":"port","text":"<pre><code>port()\n</code></pre> <p>Returns the port number of the socket address.</p>"},{"location":"api/core/#configuration","title":"Configuration","text":""},{"location":"api/core/#rnet.ClientConfig","title":"rnet.ClientConfig","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"api/core/#rnet.ClientConfig.emulation","title":"emulation  <code>instance-attribute</code>","text":"<pre><code>emulation\n</code></pre> <p>Emulation config.</p>"},{"location":"api/core/#rnet.ClientConfig.user_agent","title":"user_agent  <code>instance-attribute</code>","text":"<pre><code>user_agent\n</code></pre> <p>Sets the <code>User-Agent</code> header to be used by this client.</p>"},{"location":"api/core/#rnet.ClientConfig.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>Sets the default headers for every request.</p>"},{"location":"api/core/#rnet.ClientConfig.orig_headers","title":"orig_headers  <code>instance-attribute</code>","text":"<pre><code>orig_headers\n</code></pre> <p>Sets the original headers for every request.</p>"},{"location":"api/core/#rnet.ClientConfig.referer","title":"referer  <code>instance-attribute</code>","text":"<pre><code>referer\n</code></pre> <p>Enable or disable automatic setting of the <code>Referer</code> header.</p>"},{"location":"api/core/#rnet.ClientConfig.redirect","title":"redirect  <code>instance-attribute</code>","text":"<pre><code>redirect\n</code></pre> <p>Set a <code>redirect.Policy</code> for this client.</p>"},{"location":"api/core/#rnet.ClientConfig.cookie_store","title":"cookie_store  <code>instance-attribute</code>","text":"<pre><code>cookie_store\n</code></pre> <p>Enable a persistent cookie store for the client.</p>"},{"location":"api/core/#rnet.ClientConfig.cookie_provider","title":"cookie_provider  <code>instance-attribute</code>","text":"<pre><code>cookie_provider\n</code></pre> <p>Set the persistent cookie store for the client.</p> <p>Cookies received in responses will be passed to this store, and additional requests will query this store for cookies.</p> <p>By default, no cookie store is used.</p>"},{"location":"api/core/#rnet.ClientConfig.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout\n</code></pre> <p>Enables a request timeout.</p> <p>The timeout is applied from when the request starts connecting until the response body has finished.</p> <p>Default is no timeout.</p>"},{"location":"api/core/#rnet.ClientConfig.connect_timeout","title":"connect_timeout  <code>instance-attribute</code>","text":"<pre><code>connect_timeout\n</code></pre> <p>Set a timeout for only the connect phase of a <code>Client</code>.</p>"},{"location":"api/core/#rnet.ClientConfig.read_timeout","title":"read_timeout  <code>instance-attribute</code>","text":"<pre><code>read_timeout\n</code></pre> <p>Set a timeout for only the read phase of a <code>Client</code>.</p>"},{"location":"api/core/#rnet.ClientConfig.tcp_keepalive","title":"tcp_keepalive  <code>instance-attribute</code>","text":"<pre><code>tcp_keepalive\n</code></pre> <p>Set that all sockets have <code>SO_KEEPALIVE</code> set with the supplied duration.</p> <p>Default is 15 seconds.</p>"},{"location":"api/core/#rnet.ClientConfig.tcp_keepalive_interval","title":"tcp_keepalive_interval  <code>instance-attribute</code>","text":"<pre><code>tcp_keepalive_interval\n</code></pre> <p>Set that all sockets have <code>SO_KEEPALIVE</code> set with the supplied interval.</p> <p>Default is 15 seconds.</p>"},{"location":"api/core/#rnet.ClientConfig.tcp_keepalive_retries","title":"tcp_keepalive_retries  <code>instance-attribute</code>","text":"<pre><code>tcp_keepalive_retries\n</code></pre> <p>Set that all sockets have <code>SO_KEEPALIVE</code> set with the supplied retry count.</p> <p>Default is 3 retries.</p>"},{"location":"api/core/#rnet.ClientConfig.tcp_user_timeout","title":"tcp_user_timeout  <code>instance-attribute</code>","text":"<pre><code>tcp_user_timeout\n</code></pre> <p>Set that all sockets have <code>TCP_USER_TIMEOUT</code> set with the supplied duration.</p> <p>This option controls how long transmitted data may remain unacknowledged before the connection is force-closed.</p> <p>Default is 30 seconds.</p>"},{"location":"api/core/#rnet.ClientConfig.tcp_nodelay","title":"tcp_nodelay  <code>instance-attribute</code>","text":"<pre><code>tcp_nodelay\n</code></pre> <p>Set whether sockets have <code>TCP_NODELAY</code> enabled.</p> <p>Default is <code>True</code>.</p>"},{"location":"api/core/#rnet.ClientConfig.tcp_reuse_address","title":"tcp_reuse_address  <code>instance-attribute</code>","text":"<pre><code>tcp_reuse_address\n</code></pre> <p>Enable SO_REUSEADDR.</p>"},{"location":"api/core/#rnet.ClientConfig.pool_idle_timeout","title":"pool_idle_timeout  <code>instance-attribute</code>","text":"<pre><code>pool_idle_timeout\n</code></pre> <p>Set an optional timeout for idle sockets being kept-alive.</p>"},{"location":"api/core/#rnet.ClientConfig.pool_max_idle_per_host","title":"pool_max_idle_per_host  <code>instance-attribute</code>","text":"<pre><code>pool_max_idle_per_host\n</code></pre> <p>Sets the maximum idle connection per host allowed in the pool.</p>"},{"location":"api/core/#rnet.ClientConfig.pool_max_size","title":"pool_max_size  <code>instance-attribute</code>","text":"<pre><code>pool_max_size\n</code></pre> <p>Sets the maximum number of connections in the pool.</p>"},{"location":"api/core/#rnet.ClientConfig.http1_only","title":"http1_only  <code>instance-attribute</code>","text":"<pre><code>http1_only\n</code></pre> <p>Only use HTTP/1.</p>"},{"location":"api/core/#rnet.ClientConfig.http2_only","title":"http2_only  <code>instance-attribute</code>","text":"<pre><code>http2_only\n</code></pre> <p>Only use HTTP/2.</p>"},{"location":"api/core/#rnet.ClientConfig.https_only","title":"https_only  <code>instance-attribute</code>","text":"<pre><code>https_only\n</code></pre> <p>Restrict the Client to be used with HTTPS only requests.</p>"},{"location":"api/core/#rnet.ClientConfig.http1_options","title":"http1_options  <code>instance-attribute</code>","text":"<pre><code>http1_options\n</code></pre> <p>Sets the HTTP/1 options for the client.</p>"},{"location":"api/core/#rnet.ClientConfig.http2_options","title":"http2_options  <code>instance-attribute</code>","text":"<pre><code>http2_options\n</code></pre> <p>Sets the HTTP/2 options for the client.</p>"},{"location":"api/core/#rnet.ClientConfig.verify","title":"verify  <code>instance-attribute</code>","text":"<pre><code>verify\n</code></pre> <p>Sets whether to verify TLS certificates.</p>"},{"location":"api/core/#rnet.ClientConfig.verify_hostname","title":"verify_hostname  <code>instance-attribute</code>","text":"<pre><code>verify_hostname\n</code></pre> <p>Configures the use of hostname verification when connecting.</p>"},{"location":"api/core/#rnet.ClientConfig.identity","title":"identity  <code>instance-attribute</code>","text":"<pre><code>identity\n</code></pre> <p>Represents a private key and X509 cert as a client certificate.</p>"},{"location":"api/core/#rnet.ClientConfig.keylog","title":"keylog  <code>instance-attribute</code>","text":"<pre><code>keylog\n</code></pre> <p>Key logging policy (environment or file).</p>"},{"location":"api/core/#rnet.ClientConfig.tls_info","title":"tls_info  <code>instance-attribute</code>","text":"<pre><code>tls_info\n</code></pre> <p>Add TLS information as <code>TlsInfo</code> extension to responses.</p>"},{"location":"api/core/#rnet.ClientConfig.min_tls_version","title":"min_tls_version  <code>instance-attribute</code>","text":"<pre><code>min_tls_version\n</code></pre> <p>Minimum TLS version.</p>"},{"location":"api/core/#rnet.ClientConfig.max_tls_version","title":"max_tls_version  <code>instance-attribute</code>","text":"<pre><code>max_tls_version\n</code></pre> <p>Maximum TLS version.</p>"},{"location":"api/core/#rnet.ClientConfig.tls_options","title":"tls_options  <code>instance-attribute</code>","text":"<pre><code>tls_options\n</code></pre> <p>Sets the TLS options.</p>"},{"location":"api/core/#rnet.ClientConfig.no_proxy","title":"no_proxy  <code>instance-attribute</code>","text":"<pre><code>no_proxy\n</code></pre> <p>Clear all <code>proxies</code>, so <code>Client</code> will use no proxy anymore.</p> <p>This also disables the automatic usage of the \"system\" proxy.</p>"},{"location":"api/core/#rnet.ClientConfig.proxies","title":"proxies  <code>instance-attribute</code>","text":"<pre><code>proxies\n</code></pre> <p>Add a <code>Proxy</code> list to the client.</p>"},{"location":"api/core/#rnet.ClientConfig.local_address","title":"local_address  <code>instance-attribute</code>","text":"<pre><code>local_address\n</code></pre> <p>Bind to a local IP Address.</p>"},{"location":"api/core/#rnet.ClientConfig.local_addresses","title":"local_addresses  <code>instance-attribute</code>","text":"<pre><code>local_addresses\n</code></pre> <p>Bind to dual-stack local IP Addresses.</p>"},{"location":"api/core/#rnet.ClientConfig.interface","title":"interface  <code>instance-attribute</code>","text":"<pre><code>interface\n</code></pre> <p>Bind connections only on the specified network interface.</p> <p>This option is only available on the following operating systems:</p> <ul> <li>Android</li> <li>Fuchsia</li> <li>Linux</li> <li>macOS and macOS-like systems (iOS, tvOS, watchOS and visionOS)</li> <li>Solaris and illumos</li> </ul> <p>On Android, Linux, and Fuchsia, this uses the [<code>SO_BINDTODEVICE</code>][man-7-socket] socket option. On macOS and macOS-like systems, Solaris, and illumos, this instead uses the [<code>IP_BOUND_IF</code> and  <code>IPV6_BOUND_IF</code>][man-7p-ip] socket options (as appropriate).</p> <p>Note that connections will fail if the provided interface name is not a network interface that currently exists when a connection is established.</p>"},{"location":"api/core/#rnet.ClientConfig.gzip","title":"gzip  <code>instance-attribute</code>","text":"<pre><code>gzip\n</code></pre> <p>Enable auto gzip decompression by checking the <code>Content-Encoding</code> response header.</p>"},{"location":"api/core/#rnet.ClientConfig.brotli","title":"brotli  <code>instance-attribute</code>","text":"<pre><code>brotli\n</code></pre> <p>Enable auto brotli decompression by checking the <code>Content-Encoding</code> response header.</p>"},{"location":"api/core/#rnet.ClientConfig.deflate","title":"deflate  <code>instance-attribute</code>","text":"<pre><code>deflate\n</code></pre> <p>Enable auto deflate decompression by checking the <code>Content-Encoding</code> response header.</p>"},{"location":"api/core/#rnet.ClientConfig.zstd","title":"zstd  <code>instance-attribute</code>","text":"<pre><code>zstd\n</code></pre> <p>Enable auto zstd decompression by checking the <code>Content-Encoding</code> response header.</p>"},{"location":"api/dns/","title":"rnet.dns","text":"<p>DNS resolution settings and custom nameservers.</p>"},{"location":"api/dns/#rnet.dns","title":"rnet.dns","text":"<p>DNS resolution types and utilities.</p>"},{"location":"api/dns/#rnet.dns.LookupIpStrategy","title":"LookupIpStrategy","text":"<p>               Bases: <code>Enum</code></p> <p>IP lookup strategy for DNS resolution.</p> <p>Determines the order and types of IP addresses to resolve.</p> Source code in <code>rnet/dns.py</code> <pre><code>@final\nclass LookupIpStrategy(Enum):\n    \"\"\"IP lookup strategy for DNS resolution.\n\n    Determines the order and types of IP addresses to resolve.\n    \"\"\"\n\n    IPV4_ONLY = auto()\n    \"\"\"Only resolve IPv4 addresses.\"\"\"\n\n    IPV6_ONLY = auto()\n    \"\"\"Only resolve IPv6 addresses.\"\"\"\n\n    IPV4_AND_IPV6 = auto()\n    \"\"\"Resolve both IPv4 and IPv6 addresses.\"\"\"\n\n    IPV6_THEN_IPV4 = auto()\n    \"\"\"Prefer IPv6, fall back to IPv4.\"\"\"\n\n    IPV4_THEN_IPV6 = auto()\n    \"\"\"Prefer IPv4, fall back to IPv6.\"\"\"\n</code></pre>"},{"location":"api/dns/#rnet.dns.LookupIpStrategy.IPV4_ONLY","title":"IPV4_ONLY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IPV4_ONLY = auto()\n</code></pre> <p>Only resolve IPv4 addresses.</p>"},{"location":"api/dns/#rnet.dns.LookupIpStrategy.IPV6_ONLY","title":"IPV6_ONLY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IPV6_ONLY = auto()\n</code></pre> <p>Only resolve IPv6 addresses.</p>"},{"location":"api/dns/#rnet.dns.LookupIpStrategy.IPV4_AND_IPV6","title":"IPV4_AND_IPV6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IPV4_AND_IPV6 = auto()\n</code></pre> <p>Resolve both IPv4 and IPv6 addresses.</p>"},{"location":"api/dns/#rnet.dns.LookupIpStrategy.IPV6_THEN_IPV4","title":"IPV6_THEN_IPV4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IPV6_THEN_IPV4 = auto()\n</code></pre> <p>Prefer IPv6, fall back to IPv4.</p>"},{"location":"api/dns/#rnet.dns.LookupIpStrategy.IPV4_THEN_IPV6","title":"IPV4_THEN_IPV6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IPV4_THEN_IPV6 = auto()\n</code></pre> <p>Prefer IPv4, fall back to IPv6.</p>"},{"location":"api/dns/#rnet.dns.ResolverOptions","title":"ResolverOptions","text":"<p>DNS resolver options for customizing DNS resolution behavior.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_ip_strategy</code> <code>LookupIpStrategy</code> <p>The IP lookup strategy to use. Defaults to IPV4_AND_IPV6.</p> <code>IPV4_AND_IPV6</code> Example <p>from rnet import ResolverOptions, LookupIpStrategy from ipaddress import IPv4Address options = ResolverOptions(LookupIpStrategy.Ipv4Only) options.add_resolve(\"example.com\", [IPv4Address(\"127.0.0.1\")])</p> Source code in <code>rnet/dns.py</code> <pre><code>class ResolverOptions:\n    \"\"\"DNS resolver options for customizing DNS resolution behavior.\n\n    Args:\n        lookup_ip_strategy: The IP lookup strategy to use. Defaults to IPV4_AND_IPV6.\n\n    Example:\n        &gt;&gt;&gt; from rnet import ResolverOptions, LookupIpStrategy\n        &gt;&gt;&gt; from ipaddress import IPv4Address\n        &gt;&gt;&gt; options = ResolverOptions(LookupIpStrategy.Ipv4Only)\n        &gt;&gt;&gt; options.add_resolve(\"example.com\", [IPv4Address(\"127.0.0.1\")])\n    \"\"\"\n\n    def __init__(\n        self,\n        lookup_ip_strategy: LookupIpStrategy = LookupIpStrategy.IPV4_AND_IPV6,\n    ) -&gt; None:\n        \"\"\"Create a new ResolverOptions with the given lookup IP strategy.\n\n        Args:\n            lookup_ip_strategy: The IP lookup strategy to use.\n        \"\"\"\n        ...\n\n    def add_resolve(\n        self,\n        domain: str,\n        addrs: Sequence[IPv4Address | IPv6Address],\n    ) -&gt; None:\n        \"\"\"Add a custom DNS resolve mapping.\n\n        Maps a domain name to a list of IP addresses, bypassing normal DNS resolution.\n\n        Args:\n            domain: The domain name to map.\n            addrs: List of IP addresses to resolve the domain to.\n\n        Example:\n            &gt;&gt;&gt; from ipaddress import IPv4Address, IPv6Address\n            &gt;&gt;&gt; options = ResolverOptions()\n            &gt;&gt;&gt; options.add_resolve(\"api.example.com\", [IPv4Address(\"192.168.1.1\")])\n            &gt;&gt;&gt; options.add_resolve(\"cdn.example.com\", [\n            ...     IPv6Address(\"2001:db8::1\"),\n            ...     IPv4Address(\"203.0.113.1\"),\n            ... ])\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/dns/#rnet.dns.ResolverOptions.__init__","title":"__init__","text":"<pre><code>__init__(lookup_ip_strategy=LookupIpStrategy.IPV4_AND_IPV6)\n</code></pre> <p>Create a new ResolverOptions with the given lookup IP strategy.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_ip_strategy</code> <code>LookupIpStrategy</code> <p>The IP lookup strategy to use.</p> <code>IPV4_AND_IPV6</code> Source code in <code>rnet/dns.py</code> <pre><code>def __init__(\n    self,\n    lookup_ip_strategy: LookupIpStrategy = LookupIpStrategy.IPV4_AND_IPV6,\n) -&gt; None:\n    \"\"\"Create a new ResolverOptions with the given lookup IP strategy.\n\n    Args:\n        lookup_ip_strategy: The IP lookup strategy to use.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/dns/#rnet.dns.ResolverOptions.add_resolve","title":"add_resolve","text":"<pre><code>add_resolve(domain, addrs)\n</code></pre> <p>Add a custom DNS resolve mapping.</p> <p>Maps a domain name to a list of IP addresses, bypassing normal DNS resolution.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain name to map.</p> required <code>addrs</code> <code>Sequence[IPv4Address | IPv6Address]</code> <p>List of IP addresses to resolve the domain to.</p> required Example <p>from ipaddress import IPv4Address, IPv6Address options = ResolverOptions() options.add_resolve(\"api.example.com\", [IPv4Address(\"192.168.1.1\")]) options.add_resolve(\"cdn.example.com\", [ ...     IPv6Address(\"2001:db8::1\"), ...     IPv4Address(\"203.0.113.1\"), ... ])</p> Source code in <code>rnet/dns.py</code> <pre><code>def add_resolve(\n    self,\n    domain: str,\n    addrs: Sequence[IPv4Address | IPv6Address],\n) -&gt; None:\n    \"\"\"Add a custom DNS resolve mapping.\n\n    Maps a domain name to a list of IP addresses, bypassing normal DNS resolution.\n\n    Args:\n        domain: The domain name to map.\n        addrs: List of IP addresses to resolve the domain to.\n\n    Example:\n        &gt;&gt;&gt; from ipaddress import IPv4Address, IPv6Address\n        &gt;&gt;&gt; options = ResolverOptions()\n        &gt;&gt;&gt; options.add_resolve(\"api.example.com\", [IPv4Address(\"192.168.1.1\")])\n        &gt;&gt;&gt; options.add_resolve(\"cdn.example.com\", [\n        ...     IPv6Address(\"2001:db8::1\"),\n        ...     IPv4Address(\"203.0.113.1\"),\n        ... ])\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/emulation/","title":"rnet.emulation","text":"<p>Browser and client emulation settings to bypass detection and fingerprinting.</p>"},{"location":"api/emulation/#rnet.emulation","title":"rnet.emulation","text":"<p>This module provides functionality for emulating various browsers and HTTP clients to bypass detection and fingerprinting. It supports emulating Chrome, Firefox, Edge, Safari, Opera, and OkHttp clients across different operating systems and versions.</p> <p>The emulation system modifies HTTP/2 settings, TLS fingerprints, and request headers to match the behavior of real browsers and clients, making requests appear more authentic and less likely to be blocked by anti-bot systems.</p>"},{"location":"api/emulation/#rnet.emulation.Emulation","title":"Emulation","text":"<p>               Bases: <code>Enum</code></p> <p>An emulation.</p> Source code in <code>rnet/emulation.py</code> <pre><code>@final\nclass Emulation(Enum):\n    r\"\"\"\n    An emulation.\n    \"\"\"\n\n    # Chrome versions\n    Chrome100 = auto()\n    Chrome101 = auto()\n    Chrome104 = auto()\n    Chrome105 = auto()\n    Chrome106 = auto()\n    Chrome107 = auto()\n    Chrome108 = auto()\n    Chrome109 = auto()\n    Chrome110 = auto()\n    Chrome114 = auto()\n    Chrome116 = auto()\n    Chrome117 = auto()\n    Chrome118 = auto()\n    Chrome119 = auto()\n    Chrome120 = auto()\n    Chrome123 = auto()\n    Chrome124 = auto()\n    Chrome126 = auto()\n    Chrome127 = auto()\n    Chrome128 = auto()\n    Chrome129 = auto()\n    Chrome130 = auto()\n    Chrome131 = auto()\n    Chrome132 = auto()\n    Chrome133 = auto()\n    Chrome134 = auto()\n    Chrome135 = auto()\n    Chrome136 = auto()\n    Chrome137 = auto()\n    Chrome138 = auto()\n    Chrome139 = auto()\n    Chrome140 = auto()\n    Chrome141 = auto()\n    Chrome142 = auto()\n    Chrome143 = auto()\n\n    # Microsoft Edge versions\n    Edge101 = auto()\n    Edge122 = auto()\n    Edge127 = auto()\n    Edge131 = auto()\n    Edge134 = auto()\n    Edge135 = auto()\n    Edge136 = auto()\n    Edge137 = auto()\n    Edge138 = auto()\n    Edge139 = auto()\n    Edge140 = auto()\n    Edge141 = auto()\n    Edge142 = auto()\n\n    # Firefox versions\n    Firefox109 = auto()\n    Firefox117 = auto()\n    Firefox128 = auto()\n    Firefox133 = auto()\n    Firefox135 = auto()\n    FirefoxPrivate135 = auto()\n    FirefoxAndroid135 = auto()\n    Firefox136 = auto()\n    FirefoxPrivate136 = auto()\n    Firefox139 = auto()\n    Firefox142 = auto()\n    Firefox143 = auto()\n    Firefox144 = auto()\n    Firefox145 = auto()\n    Firefox146 = auto()\n\n    # Safari versions\n    SafariIos17_2 = auto()\n    SafariIos17_4_1 = auto()\n    SafariIos16_5 = auto()\n    Safari15_3 = auto()\n    Safari15_5 = auto()\n    Safari15_6_1 = auto()\n    Safari16 = auto()\n    Safari16_5 = auto()\n    Safari17_0 = auto()\n    Safari17_2_1 = auto()\n    Safari17_4_1 = auto()\n    Safari17_5 = auto()\n    Safari18 = auto()\n    SafariIPad18 = auto()\n    Safari18_2 = auto()\n    Safari18_3 = auto()\n    Safari18_3_1 = auto()\n    SafariIos18_1_1 = auto()\n    Safari18_5 = auto()\n    Safari26 = auto()\n    Safari26_1 = auto()\n    Safari26_2 = auto()\n    SafariIos26 = auto()\n    SafariIos26_2 = auto()\n    SafariIPad26 = auto()\n    SafariIpad26_2 = auto()\n\n    # OkHttp versions\n    OkHttp3_9 = auto()\n    OkHttp3_11 = auto()\n    OkHttp3_13 = auto()\n    OkHttp3_14 = auto()\n    OkHttp4_9 = auto()\n    OkHttp4_10 = auto()\n    OkHttp4_12 = auto()\n    OkHttp5 = auto()\n\n    # Opera versions\n    Opera116 = auto()\n    Opera117 = auto()\n    Opera118 = auto()\n    Opera119 = auto()\n</code></pre>"},{"location":"api/emulation/#rnet.emulation.EmulationOS","title":"EmulationOS","text":"<p>               Bases: <code>Enum</code></p> <p>Operating systems that can be emulated.</p> <p>This enum defines the operating systems that can be combined with browser emulations to create more specific fingerprints.</p> Source code in <code>rnet/emulation.py</code> <pre><code>@final\nclass EmulationOS(Enum):\n    \"\"\"\n    Operating systems that can be emulated.\n\n    This enum defines the operating systems that can be combined with\n    browser emulations to create more specific fingerprints.\n    \"\"\"\n\n    Windows = auto()  # Windows (any version)\n    MacOS = auto()  # macOS (any version)\n    Linux = auto()  # Linux (any distribution)\n    Android = auto()  # Android (mobile)\n    IOS = auto()  # iOS (iPhone/iPad)\n</code></pre>"},{"location":"api/emulation/#rnet.emulation.EmulationOption","title":"EmulationOption","text":"<p>Configuration options for browser and client emulation.</p> <p>This class allows fine-grained control over emulation behavior, including the ability to disable specific features or combine browser types with specific operating systems.</p> Source code in <code>rnet/emulation.py</code> <pre><code>@final\nclass EmulationOption:\n    \"\"\"\n    Configuration options for browser and client emulation.\n\n    This class allows fine-grained control over emulation behavior,\n    including the ability to disable specific features or combine\n    browser types with specific operating systems.\n    \"\"\"\n\n    def __init__(\n        self,\n        emulation: Emulation,\n        emulation_os: EmulationOS | None = None,\n        skip_http2: bool | None = None,\n        skip_headers: bool | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Create a new emulation configuration.\n\n        Args:\n            emulation: The browser/client type to emulate\n            emulation_os: The operating system to emulate (optional)\n            skip_http2: Whether to disable HTTP/2 emulation (default: False)\n            skip_headers: Whether to skip default browser headers (default: False)\n\n        Returns:\n            A configured EmulationOption instance\n\n        Example:\n            ```python\n            # Basic Chrome emulation\n            option = EmulationOption(Emulation.Chrome137)\n\n            # Chrome on Windows with HTTP/2 disabled\n            option = EmulationOption(\n                emulation=Emulation.Chrome137,\n                emulation_os=EmulationOS.Windows,\n                skip_http2=True\n            )\n            ```\n        \"\"\"\n        ...\n\n    @staticmethod\n    def random() -&gt; \"EmulationOption\":\n        \"\"\"\n        Generate a random emulation configuration.\n\n        This method creates a randomized emulation setup using a random\n        browser/client type and operating system combination. Useful for\n        scenarios where you want to vary your fingerprint across requests.\n\n        Returns:\n            A randomly configured EmulationOption instance\n\n        Example:\n            ```python\n            # Use different random emulation for each client\n            client1 = rnet.Client(emulation=EmulationOption.random())\n            client2 = rnet.Client(emulation=EmulationOption.random())\n            ```\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/emulation/#rnet.emulation.EmulationOption.__init__","title":"__init__","text":"<pre><code>__init__(emulation, emulation_os=None, skip_http2=None, skip_headers=None)\n</code></pre> <p>Create a new emulation configuration.</p> <p>Parameters:</p> Name Type Description Default <code>emulation</code> <code>Emulation</code> <p>The browser/client type to emulate</p> required <code>emulation_os</code> <code>EmulationOS | None</code> <p>The operating system to emulate (optional)</p> <code>None</code> <code>skip_http2</code> <code>bool | None</code> <p>Whether to disable HTTP/2 emulation (default: False)</p> <code>None</code> <code>skip_headers</code> <code>bool | None</code> <p>Whether to skip default browser headers (default: False)</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A configured EmulationOption instance</p> Example <pre><code># Basic Chrome emulation\noption = EmulationOption(Emulation.Chrome137)\n\n# Chrome on Windows with HTTP/2 disabled\noption = EmulationOption(\n    emulation=Emulation.Chrome137,\n    emulation_os=EmulationOS.Windows,\n    skip_http2=True\n)\n</code></pre> Source code in <code>rnet/emulation.py</code> <pre><code>def __init__(\n    self,\n    emulation: Emulation,\n    emulation_os: EmulationOS | None = None,\n    skip_http2: bool | None = None,\n    skip_headers: bool | None = None,\n) -&gt; None:\n    \"\"\"\n    Create a new emulation configuration.\n\n    Args:\n        emulation: The browser/client type to emulate\n        emulation_os: The operating system to emulate (optional)\n        skip_http2: Whether to disable HTTP/2 emulation (default: False)\n        skip_headers: Whether to skip default browser headers (default: False)\n\n    Returns:\n        A configured EmulationOption instance\n\n    Example:\n        ```python\n        # Basic Chrome emulation\n        option = EmulationOption(Emulation.Chrome137)\n\n        # Chrome on Windows with HTTP/2 disabled\n        option = EmulationOption(\n            emulation=Emulation.Chrome137,\n            emulation_os=EmulationOS.Windows,\n            skip_http2=True\n        )\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/emulation/#rnet.emulation.EmulationOption.random","title":"random  <code>staticmethod</code>","text":"<pre><code>random()\n</code></pre> <p>Generate a random emulation configuration.</p> <p>This method creates a randomized emulation setup using a random browser/client type and operating system combination. Useful for scenarios where you want to vary your fingerprint across requests.</p> <p>Returns:</p> Type Description <code>EmulationOption</code> <p>A randomly configured EmulationOption instance</p> Example <pre><code># Use different random emulation for each client\nclient1 = rnet.Client(emulation=EmulationOption.random())\nclient2 = rnet.Client(emulation=EmulationOption.random())\n</code></pre> Source code in <code>rnet/emulation.py</code> <pre><code>@staticmethod\ndef random() -&gt; \"EmulationOption\":\n    \"\"\"\n    Generate a random emulation configuration.\n\n    This method creates a randomized emulation setup using a random\n    browser/client type and operating system combination. Useful for\n    scenarios where you want to vary your fingerprint across requests.\n\n    Returns:\n        A randomly configured EmulationOption instance\n\n    Example:\n        ```python\n        # Use different random emulation for each client\n        client1 = rnet.Client(emulation=EmulationOption.random())\n        client2 = rnet.Client(emulation=EmulationOption.random())\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exceptions/","title":"rnet.exceptions","text":"<p>All exception types that can be raised by rnet.</p>"},{"location":"api/exceptions/#rnet.exceptions","title":"rnet.exceptions","text":"<p>HTTP Client Exceptions</p> <p>This module defines all exceptions that can be raised by the rnet HTTP client. The exceptions are organized into logical categories based on their cause and severity, making it easier to handle specific types of errors appropriately.</p>"},{"location":"api/exceptions/#rnet.exceptions.RustPanic","title":"RustPanic","text":"<p>               Bases: <code>Exception</code></p> <p>A panic occurred in the underlying Rust code.</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class RustPanic(Exception):\n    r\"\"\"\n    A panic occurred in the underlying Rust code.\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.TlsError","title":"TlsError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred in the TLS security layer.</p> <p>This exception covers TLS/SSL related issues such as: - Certificate verification failures - TLS handshake failures - Protocol version mismatches - Cipher suite negotiations</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class TlsError(Exception):\n    r\"\"\"\n    An error occurred in the TLS security layer.\n\n    This exception covers TLS/SSL related issues such as:\n    - Certificate verification failures\n    - TLS handshake failures\n    - Protocol version mismatches\n    - Cipher suite negotiations\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while establishing a connection.</p> <p>This exception is raised when the client cannot establish a TCP connection to the remote server. Common causes include: - Server is unreachable - Port is closed or blocked - Network connectivity issues - Firewall blocking the connection</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class ConnectionError(Exception):\n    r\"\"\"\n    An error occurred while establishing a connection.\n\n    This exception is raised when the client cannot establish a\n    TCP connection to the remote server. Common causes include:\n    - Server is unreachable\n    - Port is closed or blocked\n    - Network connectivity issues\n    - Firewall blocking the connection\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.ProxyConnectionError","title":"ProxyConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while connecting through a proxy server.</p> <p>This exception is raised when the client cannot establish a connection to the target server via the specified proxy. Common causes include: - Invalid proxy address or port - Proxy server is unreachable - Authentication failures with the proxy - Network connectivity issues between client and proxy</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class ProxyConnectionError(Exception):\n    r\"\"\"\n    An error occurred while connecting through a proxy server.\n\n    This exception is raised when the client cannot establish a\n    connection to the target server via the specified proxy. Common\n    causes include:\n    - Invalid proxy address or port\n    - Proxy server is unreachable\n    - Authentication failures with the proxy\n    - Network connectivity issues between client and proxy\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.ConnectionResetError","title":"ConnectionResetError","text":"<p>               Bases: <code>Exception</code></p> <p>The connection was reset by the remote peer.</p> <p>This exception occurs when an established connection is unexpectedly closed by the remote server. This can happen due to server overload, network issues, or server-side connection limits.</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class ConnectionResetError(Exception):\n    r\"\"\"\n    The connection was reset by the remote peer.\n\n    This exception occurs when an established connection is\n    unexpectedly closed by the remote server. This can happen\n    due to server overload, network issues, or server-side\n    connection limits.\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.BodyError","title":"BodyError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while processing the body of a request or response.</p> <p>This exception covers issues with reading, writing, or processing HTTP message bodies, including: - Invalid content encoding - Incomplete body data - Body size limit exceeded</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class BodyError(Exception):\n    r\"\"\"\n    An error occurred while processing the body of a request or response.\n\n    This exception covers issues with reading, writing, or processing\n    HTTP message bodies, including:\n    - Invalid content encoding\n    - Incomplete body data\n    - Body size limit exceeded\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.BuilderError","title":"BuilderError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while building a request or response.</p> <p>This exception is raised when there are issues constructing HTTP requests or responses, such as: - Invalid header combinations - Malformed request parameters - Configuration conflicts</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class BuilderError(Exception):\n    r\"\"\"\n    An error occurred while building a request or response.\n\n    This exception is raised when there are issues constructing\n    HTTP requests or responses, such as:\n    - Invalid header combinations\n    - Malformed request parameters\n    - Configuration conflicts\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.DecodingError","title":"DecodingError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while decoding a response.</p> <p>This exception covers failures in decoding response content, including: - Character encoding issues (UTF-8, Latin-1, etc.) - Compression decompression failures (gzip, deflate, etc.) - Content format parsing errors</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class DecodingError(Exception):\n    r\"\"\"\n    An error occurred while decoding a response.\n\n    This exception covers failures in decoding response content,\n    including:\n    - Character encoding issues (UTF-8, Latin-1, etc.)\n    - Compression decompression failures (gzip, deflate, etc.)\n    - Content format parsing errors\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.StatusError","title":"StatusError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while processing the status code of a response.</p> <p>This exception is typically raised for HTTP error status codes (4xx, 5xx) when automatic error handling is enabled, or when there are issues interpreting the status line.</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class StatusError(Exception):\n    r\"\"\"\n    An error occurred while processing the status code of a response.\n\n    This exception is typically raised for HTTP error status codes\n    (4xx, 5xx) when automatic error handling is enabled, or when\n    there are issues interpreting the status line.\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.RequestError","title":"RequestError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while making a request.</p> <p>This is a general exception for request-related issues that don't fit into more specific categories. It covers various problems during the request lifecycle.</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class RequestError(Exception):\n    r\"\"\"\n    An error occurred while making a request.\n\n    This is a general exception for request-related issues that\n    don't fit into more specific categories. It covers various\n    problems during the request lifecycle.\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.RedirectError","title":"RedirectError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while following a redirect.</p> <p>This exception is raised when there are issues with HTTP redirects, such as: - Too many redirects (redirect loop) - Invalid redirect location - Cross-protocol redirects when not allowed - Redirect limit exceeded</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class RedirectError(Exception):\n    r\"\"\"\n    An error occurred while following a redirect.\n\n    This exception is raised when there are issues with HTTP\n    redirects, such as:\n    - Too many redirects (redirect loop)\n    - Invalid redirect location\n    - Cross-protocol redirects when not allowed\n    - Redirect limit exceeded\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.UpgradeError","title":"UpgradeError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while upgrading a connection.</p> <p>This exception covers failures when upgrading HTTP connections to other protocols, such as: - WebSocket upgrade failures - HTTP/2 upgrade issues - Protocol negotiation errors</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class UpgradeError(Exception):\n    r\"\"\"\n    An error occurred while upgrading a connection.\n\n    This exception covers failures when upgrading HTTP connections\n    to other protocols, such as:\n    - WebSocket upgrade failures\n    - HTTP/2 upgrade issues\n    - Protocol negotiation errors\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.WebSocketError","title":"WebSocketError","text":"<p>               Bases: <code>Exception</code></p> <p>An error occurred while handling a WebSocket connection.</p> <p>This exception covers WebSocket-specific issues including: - WebSocket handshake failures - Frame parsing errors - Connection state violations - Message sending/receiving errors</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class WebSocketError(Exception):\n    r\"\"\"\n    An error occurred while handling a WebSocket connection.\n\n    This exception covers WebSocket-specific issues including:\n    - WebSocket handshake failures\n    - Frame parsing errors\n    - Connection state violations\n    - Message sending/receiving errors\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#rnet.exceptions.TimeoutError","title":"TimeoutError","text":"<p>               Bases: <code>Exception</code></p> <p>A timeout occurred while waiting for a response.</p> <p>This exception is raised when operations exceed their configured time limits, including: - Connection timeout (time to establish connection) - Read timeout (time to receive response) - Total request timeout (entire request lifecycle)</p> <p>Timeouts can often be resolved by increasing timeout values or retrying the request.</p> Source code in <code>rnet/exceptions.py</code> <pre><code>class TimeoutError(Exception):\n    r\"\"\"\n    A timeout occurred while waiting for a response.\n\n    This exception is raised when operations exceed their configured\n    time limits, including:\n    - Connection timeout (time to establish connection)\n    - Read timeout (time to receive response)\n    - Total request timeout (entire request lifecycle)\n\n    Timeouts can often be resolved by increasing timeout values\n    or retrying the request.\n    \"\"\"\n</code></pre>"},{"location":"api/header/","title":"rnet.header","text":"<p>HTTP header management with case-insensitive keys and multiple values support.</p>"},{"location":"api/header/#rnet.header","title":"rnet.header","text":"<p>HTTP Header Management</p> <p>This module provides efficient storage and manipulation of HTTP headers with support for multiple values per header name. The HeaderMap class is designed to handle the complexities of HTTP header processing, including case-insensitive header names and multiple header values.</p> <p>The implementation follows HTTP specifications (RFC 7230) for header handling, including proper support for headers that can have multiple values (like Set-Cookie, Accept-Encoding, etc.).</p>"},{"location":"api/header/#rnet.header.HeaderMap","title":"HeaderMap","text":"<p>A case-insensitive HTTP header map supporting multiple values per header.</p> <p>This class provides efficient storage and retrieval of HTTP headers, automatically handling case-insensitive header names and supporting headers with multiple values (such as Set-Cookie or Accept-Encoding).</p> <p>The implementation follows HTTP/1.1 specifications for header handling and provides both dictionary-like access and specialized methods for HTTP header manipulation.</p> Source code in <code>rnet/header.py</code> <pre><code>class HeaderMap:\n    r\"\"\"\n    A case-insensitive HTTP header map supporting multiple values per header.\n\n    This class provides efficient storage and retrieval of HTTP headers,\n    automatically handling case-insensitive header names and supporting\n    headers with multiple values (such as Set-Cookie or Accept-Encoding).\n\n    The implementation follows HTTP/1.1 specifications for header handling\n    and provides both dictionary-like access and specialized methods for\n    HTTP header manipulation.\n    \"\"\"\n\n    def __getitem__(self, key: str) -&gt; bytes | None:\n        \"\"\"Get the first value for a header name (case-insensitive).\"\"\"\n        ...\n\n    def __setitem__(self, key: str, value: str) -&gt; None:\n        \"\"\"Set a header to a single value, replacing any existing values.\"\"\"\n        ...\n\n    def __delitem__(self, key: str) -&gt; None:\n        \"\"\"Remove all values for a header name.\"\"\"\n        ...\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Check if a header name exists (case-insensitive).\"\"\"\n        ...\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the total number of header values (not unique names).\"\"\"\n        ...\n\n    def __iter__(self) -&gt; Iterator[Tuple[bytes, bytes]]:\n        \"\"\"Iterate all header(name, value) pairs, including duplicates for multiple values.\"\"\"\n        ...\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of all headers.\"\"\"\n        ...\n\n    def __init__(\n        self, init: Dict[str, str] | None = None, capacity: int | None = None\n    ) -&gt; None:\n        \"\"\"\n        Create a new HeaderMap.\n\n        Args:\n            init: Optional dictionary to initialize headers from\n            capacity: Optional initial capacity hint for performance\n\n        Returns:\n            A new HeaderMap instance\n\n        Example:\n            ```python\n            # Empty header map\n            headers = HeaderMap()\n\n            # Initialize from dictionary\n            headers = HeaderMap({\n                'Content-Type': 'text/html',\n                'Cache-Control': 'no-cache'\n            })\n\n            # Pre-allocate capacity for performance\n            headers = HeaderMap(capacity=50)\n            ```\n        \"\"\"\n\n    def contains_key(self, key: str) -&gt; bool:\n        r\"\"\"\n        Check if the header map contains the given key.\n\n        This is equivalent to using the 'in' operator but provides\n        an explicit method name. Header name comparison is case-insensitive.\n\n        Args:\n            key: The header name to check\n\n        Returns:\n            True if the header exists, False otherwise\n        \"\"\"\n        ...\n\n    def insert(self, key: str, value: str) -&gt; None:\n        r\"\"\"\n        Insert a header, replacing any existing values.\n\n        This method replaces all existing values for the given header name\n        with the new value. For adding additional values, use append() instead.\n\n        Args:\n            key: The header name (case-insensitive)\n            value: The header value to set\n        \"\"\"\n        ...\n\n    def append(self, key: str, value: str) -&gt; None:\n        r\"\"\"\n        Append a value to an existing header or create a new one.\n\n        If the header already exists, this adds an additional value.\n        If the header doesn't exist, it creates a new header with this value.\n        This is useful for headers that can have multiple values.\n\n        Args:\n            key: The header name (case-insensitive)\n            value: The header value to append\n        \"\"\"\n        ...\n\n    def remove(self, key: str) -&gt; None:\n        r\"\"\"\n        Remove all values for a header name.\n\n        This removes the header entirely from the map. If the header\n        doesn't exist, this method does nothing.\n\n        Args:\n            key: The header name to remove (case-insensitive)\n        \"\"\"\n        ...\n\n    def get(self, key: str, default: bytes | None = None) -&gt; bytes | None:\n        r\"\"\"\n        Get the first value for a header name with optional default.\n\n        Returns the first value associated with the header name, or the\n        default value if the header doesn't exist. For headers with multiple\n        values, use get_all() to retrieve all values.\n\n        Args:\n            key: The header name (case-insensitive)\n            default: Value to return if header doesn't exist\n\n        Returns:\n            The first header value as bytes, or the default value\n        \"\"\"\n        ...\n\n    def get_all(self, key: str) -&gt; Iterator[bytes]:\n        r\"\"\"\n        Get all values for a header name.\n\n        Returns an iterator over all values associated with the header name.\n        This is useful for headers that can have multiple values, such as\n        Set-Cookie, Accept-Encoding, or custom headers.\n\n        Args:\n            key: The header name (case-insensitive)\n\n        Returns:\n            An iterator over all header values\n        \"\"\"\n        ...\n\n    def values(self) -&gt; Iterator[bytes]:\n        \"\"\"\n        Iterate over all header values.\n\n        Returns:\n            An iterator over all header values as bytes.\n        \"\"\"\n        ...\n\n    def keys(self) -&gt; Iterator[bytes]:\n        \"\"\"\n        Iterate over unique header names.\n\n        Returns:\n            An iterator over unique header names as bytes.\n        \"\"\"\n        ...\n\n    def len(self) -&gt; int:\n        \"\"\"\n        Get the total number of header values.\n\n        This returns the total count of header values, which can be greater\n        than the number of unique header names if some headers have multiple\n        values.\n\n        Returns:\n            Total number of header values stored\n        \"\"\"\n        ...\n\n    def keys_len(self) -&gt; int:\n        \"\"\"\n        Get the number of unique header names.\n\n        This returns the count of unique header names, regardless of how\n        many values each header has.\n\n        Returns:\n            Number of unique header names\n        \"\"\"\n        ...\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\n        Check if the header map is empty.\n\n        Returns:\n            True if no headers are stored, False otherwise\n        \"\"\"\n        ...\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Remove all headers from the map.\n\n        After calling this method, the header map will be empty and\n        is_empty() will return True.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Get the first value for a header name (case-insensitive).</p> Source code in <code>rnet/header.py</code> <pre><code>def __getitem__(self, key: str) -&gt; bytes | None:\n    \"\"\"Get the first value for a header name (case-insensitive).\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set a header to a single value, replacing any existing values.</p> Source code in <code>rnet/header.py</code> <pre><code>def __setitem__(self, key: str, value: str) -&gt; None:\n    \"\"\"Set a header to a single value, replacing any existing values.\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key)\n</code></pre> <p>Remove all values for a header name.</p> Source code in <code>rnet/header.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n    \"\"\"Remove all values for a header name.\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__contains__","title":"__contains__","text":"<pre><code>__contains__(key)\n</code></pre> <p>Check if a header name exists (case-insensitive).</p> Source code in <code>rnet/header.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Check if a header name exists (case-insensitive).\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return the total number of header values (not unique names).</p> Source code in <code>rnet/header.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the total number of header values (not unique names).\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate all header(name, value) pairs, including duplicates for multiple values.</p> Source code in <code>rnet/header.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Tuple[bytes, bytes]]:\n    \"\"\"Iterate all header(name, value) pairs, including duplicates for multiple values.\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return a string representation of all headers.</p> Source code in <code>rnet/header.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of all headers.\"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.__init__","title":"__init__","text":"<pre><code>__init__(init=None, capacity=None)\n</code></pre> <p>Create a new HeaderMap.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>Dict[str, str] | None</code> <p>Optional dictionary to initialize headers from</p> <code>None</code> <code>capacity</code> <code>int | None</code> <p>Optional initial capacity hint for performance</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A new HeaderMap instance</p> Example <pre><code># Empty header map\nheaders = HeaderMap()\n\n# Initialize from dictionary\nheaders = HeaderMap({\n    'Content-Type': 'text/html',\n    'Cache-Control': 'no-cache'\n})\n\n# Pre-allocate capacity for performance\nheaders = HeaderMap(capacity=50)\n</code></pre> Source code in <code>rnet/header.py</code> <pre><code>def __init__(\n    self, init: Dict[str, str] | None = None, capacity: int | None = None\n) -&gt; None:\n    \"\"\"\n    Create a new HeaderMap.\n\n    Args:\n        init: Optional dictionary to initialize headers from\n        capacity: Optional initial capacity hint for performance\n\n    Returns:\n        A new HeaderMap instance\n\n    Example:\n        ```python\n        # Empty header map\n        headers = HeaderMap()\n\n        # Initialize from dictionary\n        headers = HeaderMap({\n            'Content-Type': 'text/html',\n            'Cache-Control': 'no-cache'\n        })\n\n        # Pre-allocate capacity for performance\n        headers = HeaderMap(capacity=50)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.contains_key","title":"contains_key","text":"<pre><code>contains_key(key)\n</code></pre> <p>Check if the header map contains the given key.</p> <p>This is equivalent to using the 'in' operator but provides an explicit method name. Header name comparison is case-insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The header name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the header exists, False otherwise</p> Source code in <code>rnet/header.py</code> <pre><code>def contains_key(self, key: str) -&gt; bool:\n    r\"\"\"\n    Check if the header map contains the given key.\n\n    This is equivalent to using the 'in' operator but provides\n    an explicit method name. Header name comparison is case-insensitive.\n\n    Args:\n        key: The header name to check\n\n    Returns:\n        True if the header exists, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.insert","title":"insert","text":"<pre><code>insert(key, value)\n</code></pre> <p>Insert a header, replacing any existing values.</p> <p>This method replaces all existing values for the given header name with the new value. For adding additional values, use append() instead.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The header name (case-insensitive)</p> required <code>value</code> <code>str</code> <p>The header value to set</p> required Source code in <code>rnet/header.py</code> <pre><code>def insert(self, key: str, value: str) -&gt; None:\n    r\"\"\"\n    Insert a header, replacing any existing values.\n\n    This method replaces all existing values for the given header name\n    with the new value. For adding additional values, use append() instead.\n\n    Args:\n        key: The header name (case-insensitive)\n        value: The header value to set\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.append","title":"append","text":"<pre><code>append(key, value)\n</code></pre> <p>Append a value to an existing header or create a new one.</p> <p>If the header already exists, this adds an additional value. If the header doesn't exist, it creates a new header with this value. This is useful for headers that can have multiple values.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The header name (case-insensitive)</p> required <code>value</code> <code>str</code> <p>The header value to append</p> required Source code in <code>rnet/header.py</code> <pre><code>def append(self, key: str, value: str) -&gt; None:\n    r\"\"\"\n    Append a value to an existing header or create a new one.\n\n    If the header already exists, this adds an additional value.\n    If the header doesn't exist, it creates a new header with this value.\n    This is useful for headers that can have multiple values.\n\n    Args:\n        key: The header name (case-insensitive)\n        value: The header value to append\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.remove","title":"remove","text":"<pre><code>remove(key)\n</code></pre> <p>Remove all values for a header name.</p> <p>This removes the header entirely from the map. If the header doesn't exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The header name to remove (case-insensitive)</p> required Source code in <code>rnet/header.py</code> <pre><code>def remove(self, key: str) -&gt; None:\n    r\"\"\"\n    Remove all values for a header name.\n\n    This removes the header entirely from the map. If the header\n    doesn't exist, this method does nothing.\n\n    Args:\n        key: The header name to remove (case-insensitive)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Get the first value for a header name with optional default.</p> <p>Returns the first value associated with the header name, or the default value if the header doesn't exist. For headers with multiple values, use get_all() to retrieve all values.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The header name (case-insensitive)</p> required <code>default</code> <code>bytes | None</code> <p>Value to return if header doesn't exist</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | None</code> <p>The first header value as bytes, or the default value</p> Source code in <code>rnet/header.py</code> <pre><code>def get(self, key: str, default: bytes | None = None) -&gt; bytes | None:\n    r\"\"\"\n    Get the first value for a header name with optional default.\n\n    Returns the first value associated with the header name, or the\n    default value if the header doesn't exist. For headers with multiple\n    values, use get_all() to retrieve all values.\n\n    Args:\n        key: The header name (case-insensitive)\n        default: Value to return if header doesn't exist\n\n    Returns:\n        The first header value as bytes, or the default value\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.get_all","title":"get_all","text":"<pre><code>get_all(key)\n</code></pre> <p>Get all values for a header name.</p> <p>Returns an iterator over all values associated with the header name. This is useful for headers that can have multiple values, such as Set-Cookie, Accept-Encoding, or custom headers.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The header name (case-insensitive)</p> required <p>Returns:</p> Type Description <code>Iterator[bytes]</code> <p>An iterator over all header values</p> Source code in <code>rnet/header.py</code> <pre><code>def get_all(self, key: str) -&gt; Iterator[bytes]:\n    r\"\"\"\n    Get all values for a header name.\n\n    Returns an iterator over all values associated with the header name.\n    This is useful for headers that can have multiple values, such as\n    Set-Cookie, Accept-Encoding, or custom headers.\n\n    Args:\n        key: The header name (case-insensitive)\n\n    Returns:\n        An iterator over all header values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Iterate over all header values.</p> <p>Returns:</p> Type Description <code>Iterator[bytes]</code> <p>An iterator over all header values as bytes.</p> Source code in <code>rnet/header.py</code> <pre><code>def values(self) -&gt; Iterator[bytes]:\n    \"\"\"\n    Iterate over all header values.\n\n    Returns:\n        An iterator over all header values as bytes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Iterate over unique header names.</p> <p>Returns:</p> Type Description <code>Iterator[bytes]</code> <p>An iterator over unique header names as bytes.</p> Source code in <code>rnet/header.py</code> <pre><code>def keys(self) -&gt; Iterator[bytes]:\n    \"\"\"\n    Iterate over unique header names.\n\n    Returns:\n        An iterator over unique header names as bytes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.len","title":"len","text":"<pre><code>len()\n</code></pre> <p>Get the total number of header values.</p> <p>This returns the total count of header values, which can be greater than the number of unique header names if some headers have multiple values.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total number of header values stored</p> Source code in <code>rnet/header.py</code> <pre><code>def len(self) -&gt; int:\n    \"\"\"\n    Get the total number of header values.\n\n    This returns the total count of header values, which can be greater\n    than the number of unique header names if some headers have multiple\n    values.\n\n    Returns:\n        Total number of header values stored\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.keys_len","title":"keys_len","text":"<pre><code>keys_len()\n</code></pre> <p>Get the number of unique header names.</p> <p>This returns the count of unique header names, regardless of how many values each header has.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of unique header names</p> Source code in <code>rnet/header.py</code> <pre><code>def keys_len(self) -&gt; int:\n    \"\"\"\n    Get the number of unique header names.\n\n    This returns the count of unique header names, regardless of how\n    many values each header has.\n\n    Returns:\n        Number of unique header names\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Check if the header map is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if no headers are stored, False otherwise</p> Source code in <code>rnet/header.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"\n    Check if the header map is empty.\n\n    Returns:\n        True if no headers are stored, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.HeaderMap.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Remove all headers from the map.</p> <p>After calling this method, the header map will be empty and is_empty() will return True.</p> Source code in <code>rnet/header.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Remove all headers from the map.\n\n    After calling this method, the header map will be empty and\n    is_empty() will return True.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.OrigHeaderMap","title":"OrigHeaderMap","text":"<p>A map from header names to their original casing as received in an HTTP message.</p> <p>OrigHeaderMap not only preserves the original case of each header name as it appeared in the HTTP message, but also maintains the insertion order of headers. This makes it suitable for use cases where the order of headers matters, such as HTTP/1.x message serialization, proxying, or reproducing requests/responses exactly as received.</p> <p>The map stores a mapping between the case-insensitive (standard) header name and the original case-sensitive header name as it appeared in the HTTP message.</p> Example <p>If an HTTP message included the following headers:</p> <pre><code>x-Bread: Baguette\nX-BREAD: Pain\nx-bread: Ficelle\n</code></pre> <p>Then the OrigHeaderMap would preserve both the exact casing and order of these headers: - Standard name \"x-bread\" maps to original \"x-Bread\" - Standard name \"x-bread\" maps to original \"X-BREAD\" - Standard name \"x-bread\" maps to original \"x-bread\"</p> <p>This allows the client to reproduce the exact header casing when forwarding or reconstructing the HTTP message.</p> Source code in <code>rnet/header.py</code> <pre><code>class OrigHeaderMap:\n    \"\"\"\n    A map from header names to their original casing as received in an HTTP message.\n\n    OrigHeaderMap not only preserves the original case of each header name as it appeared\n    in the HTTP message, but also maintains the insertion order of headers. This makes\n    it suitable for use cases where the order of headers matters, such as HTTP/1.x message\n    serialization, proxying, or reproducing requests/responses exactly as received.\n\n    The map stores a mapping between the case-insensitive (standard) header name and the\n    original case-sensitive header name as it appeared in the HTTP message.\n\n    Example:\n        If an HTTP message included the following headers:\n\n            x-Bread: Baguette\n            X-BREAD: Pain\n            x-bread: Ficelle\n\n        Then the OrigHeaderMap would preserve both the exact casing and order of these headers:\n        - Standard name \"x-bread\" maps to original \"x-Bread\"\n        - Standard name \"x-bread\" maps to original \"X-BREAD\"\n        - Standard name \"x-bread\" maps to original \"x-bread\"\n\n        This allows the client to reproduce the exact header casing when forwarding or\n        reconstructing the HTTP message.\n    \"\"\"\n\n    def __init__(\n        self,\n        init: Sequence[str] | None = None,\n        capacity: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Creates a new OrigHeaderMap from an optional list of header names.\n\n        Args:\n            init: Optional list of header names to initialize with.\n            capacity: Optional initial capacity for the map.\n        \"\"\"\n        ...\n\n    def __iter__(self) -&gt; Iterator[Tuple[bytes, bytes]]:\n        \"\"\"\n        Returns an iterator over the (standard_name, original_name) pairs.\n\n        Returns:\n            An iterator over header name pairs.\n        \"\"\"\n        ...\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of header names stored in the map.\n        \"\"\"\n        ...\n\n    def insert(self, value: str) -&gt; bool:\n        \"\"\"\n        Insert a new header name into the collection.\n\n        If the map did not previously have this key present, then False is returned.\n        If the map did have this key present, the new value is pushed to the end\n        of the list of values currently associated with the key. The key is not\n        updated, though; this matters for types that can be == without being identical.\n\n        Args:\n            value: The header name to insert.\n\n        Returns:\n            True if the key was newly inserted, False if it already existed.\n        \"\"\"\n        ...\n\n    def extend(self, other: \"OrigHeaderMap\") -&gt; None:\n        \"\"\"\n        Extends the map with all entries from another OrigHeaderMap, preserving order.\n\n        Args:\n            other: Another OrigHeaderMap to extend from.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/header/#rnet.header.OrigHeaderMap.__init__","title":"__init__","text":"<pre><code>__init__(init=None, capacity=None)\n</code></pre> <p>Creates a new OrigHeaderMap from an optional list of header names.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>Sequence[str] | None</code> <p>Optional list of header names to initialize with.</p> <code>None</code> <code>capacity</code> <code>int | None</code> <p>Optional initial capacity for the map.</p> <code>None</code> Source code in <code>rnet/header.py</code> <pre><code>def __init__(\n    self,\n    init: Sequence[str] | None = None,\n    capacity: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Creates a new OrigHeaderMap from an optional list of header names.\n\n    Args:\n        init: Optional list of header names to initialize with.\n        capacity: Optional initial capacity for the map.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.OrigHeaderMap.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Returns an iterator over the (standard_name, original_name) pairs.</p> <p>Returns:</p> Type Description <code>Iterator[Tuple[bytes, bytes]]</code> <p>An iterator over header name pairs.</p> Source code in <code>rnet/header.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Tuple[bytes, bytes]]:\n    \"\"\"\n    Returns an iterator over the (standard_name, original_name) pairs.\n\n    Returns:\n        An iterator over header name pairs.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.OrigHeaderMap.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Returns the number of header names stored in the map.</p> Source code in <code>rnet/header.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of header names stored in the map.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.OrigHeaderMap.insert","title":"insert","text":"<pre><code>insert(value)\n</code></pre> <p>Insert a new header name into the collection.</p> <p>If the map did not previously have this key present, then False is returned. If the map did have this key present, the new value is pushed to the end of the list of values currently associated with the key. The key is not updated, though; this matters for types that can be == without being identical.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The header name to insert.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key was newly inserted, False if it already existed.</p> Source code in <code>rnet/header.py</code> <pre><code>def insert(self, value: str) -&gt; bool:\n    \"\"\"\n    Insert a new header name into the collection.\n\n    If the map did not previously have this key present, then False is returned.\n    If the map did have this key present, the new value is pushed to the end\n    of the list of values currently associated with the key. The key is not\n    updated, though; this matters for types that can be == without being identical.\n\n    Args:\n        value: The header name to insert.\n\n    Returns:\n        True if the key was newly inserted, False if it already existed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/header/#rnet.header.OrigHeaderMap.extend","title":"extend","text":"<pre><code>extend(other)\n</code></pre> <p>Extends the map with all entries from another OrigHeaderMap, preserving order.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>OrigHeaderMap</code> <p>Another OrigHeaderMap to extend from.</p> required Source code in <code>rnet/header.py</code> <pre><code>def extend(self, other: \"OrigHeaderMap\") -&gt; None:\n    \"\"\"\n    Extends the map with all entries from another OrigHeaderMap, preserving order.\n\n    Args:\n        other: Another OrigHeaderMap to extend from.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http1/","title":"rnet.http1","text":"<p>Configuration options for HTTP/1.1 connections.</p>"},{"location":"api/http1/#rnet.http1","title":"rnet.http1","text":"<p>HTTP/1 connection configuration.</p>"},{"location":"api/http1/#rnet.http1.Params","title":"Params","text":"<p>               Bases: <code>TypedDict</code></p> <p>All parameters for HTTP/1 connections.</p> Source code in <code>rnet/http1.py</code> <pre><code>class Params(TypedDict):\n    \"\"\"\n    All parameters for HTTP/1 connections.\n    \"\"\"\n\n    http09_responses: NotRequired[bool]\n    \"\"\"\n    Enable support for HTTP/0.9 responses.\n    \"\"\"\n\n    writev: NotRequired[bool]\n    \"\"\"\n    Whether to use vectored writes for HTTP/1 connections.\n    \"\"\"\n\n    max_headers: NotRequired[int]\n    \"\"\"\n    Maximum number of headers allowed in HTTP/1 responses.\n    \"\"\"\n\n    read_buf_exact_size: NotRequired[int]\n    \"\"\"\n    Exact size of the read buffer to use.\n    \"\"\"\n\n    max_buf_size: NotRequired[int]\n    \"\"\"\n    Maximum buffer size for HTTP/1 connections.\n    \"\"\"\n\n    allow_spaces_after_header_name_in_responses: NotRequired[bool]\n    \"\"\"\n    Allow spaces after header names.\n    \"\"\"\n\n    ignore_invalid_headers_in_responses: NotRequired[bool]\n    \"\"\"\n    Ignore invalid headers in responses.\n    \"\"\"\n\n    allow_obsolete_multiline_headers_in_responses: NotRequired[bool]\n    \"\"\"\n    Allow obsolete multiline headers.\n    \"\"\"\n</code></pre>"},{"location":"api/http1/#rnet.http1.Params.http09_responses","title":"http09_responses  <code>instance-attribute</code>","text":"<pre><code>http09_responses\n</code></pre> <p>Enable support for HTTP/0.9 responses.</p>"},{"location":"api/http1/#rnet.http1.Params.writev","title":"writev  <code>instance-attribute</code>","text":"<pre><code>writev\n</code></pre> <p>Whether to use vectored writes for HTTP/1 connections.</p>"},{"location":"api/http1/#rnet.http1.Params.max_headers","title":"max_headers  <code>instance-attribute</code>","text":"<pre><code>max_headers\n</code></pre> <p>Maximum number of headers allowed in HTTP/1 responses.</p>"},{"location":"api/http1/#rnet.http1.Params.read_buf_exact_size","title":"read_buf_exact_size  <code>instance-attribute</code>","text":"<pre><code>read_buf_exact_size\n</code></pre> <p>Exact size of the read buffer to use.</p>"},{"location":"api/http1/#rnet.http1.Params.max_buf_size","title":"max_buf_size  <code>instance-attribute</code>","text":"<pre><code>max_buf_size\n</code></pre> <p>Maximum buffer size for HTTP/1 connections.</p>"},{"location":"api/http1/#rnet.http1.Params.allow_spaces_after_header_name_in_responses","title":"allow_spaces_after_header_name_in_responses  <code>instance-attribute</code>","text":"<pre><code>allow_spaces_after_header_name_in_responses\n</code></pre> <p>Allow spaces after header names.</p>"},{"location":"api/http1/#rnet.http1.Params.ignore_invalid_headers_in_responses","title":"ignore_invalid_headers_in_responses  <code>instance-attribute</code>","text":"<pre><code>ignore_invalid_headers_in_responses\n</code></pre> <p>Ignore invalid headers in responses.</p>"},{"location":"api/http1/#rnet.http1.Params.allow_obsolete_multiline_headers_in_responses","title":"allow_obsolete_multiline_headers_in_responses  <code>instance-attribute</code>","text":"<pre><code>allow_obsolete_multiline_headers_in_responses\n</code></pre> <p>Allow obsolete multiline headers.</p>"},{"location":"api/http1/#rnet.http1.Http1Options","title":"Http1Options","text":"<p>HTTP/1 protocol options for customizing connection behavior. These options allow you to customize the behavior of HTTP/1 connections, such as enabling support for HTTP/0.9 responses, header case preservation, etc.</p> Source code in <code>rnet/http1.py</code> <pre><code>@final\nclass Http1Options:\n    \"\"\"\n    HTTP/1 protocol options for customizing connection behavior.\n    These options allow you to customize the behavior of HTTP/1 connections,\n    such as enabling support for HTTP/0.9 responses, header case preservation, etc.\n    \"\"\"\n\n    def __init__(self, **kwargs: Unpack[Params]) -&gt; None:\n        \"\"\"\n        Crate a new Http1Options instance.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http1/#rnet.http1.Http1Options.__init__","title":"__init__","text":"<pre><code>__init__(**kwargs)\n</code></pre> <p>Crate a new Http1Options instance.</p> Source code in <code>rnet/http1.py</code> <pre><code>def __init__(self, **kwargs: Unpack[Params]) -&gt; None:\n    \"\"\"\n    Crate a new Http1Options instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/","title":"rnet.http2","text":"<p>Configuration options for HTTP/2 connections, including stream priorities and settings.</p>"},{"location":"api/http2/#rnet.http2","title":"rnet.http2","text":"<p>HTTP/2 connection configuration.</p>"},{"location":"api/http2/#rnet.http2.PseudoId","title":"PseudoId","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the order of HTTP/2 pseudo-header fields in the header block.</p> <p>HTTP/2 pseudo-header fields are a set of predefined header fields that start with ':'. The order of these fields in a header block is significant. This enum defines the possible pseudo-header fields and their standard order according to RFC 7540.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass PseudoId(Enum):\n    \"\"\"\n    Represents the order of HTTP/2 pseudo-header fields in the header block.\n\n    HTTP/2 pseudo-header fields are a set of predefined header fields that start with ':'.\n    The order of these fields in a header block is significant. This enum defines the\n    possible pseudo-header fields and their standard order according to RFC 7540.\n    \"\"\"\n\n    METHOD = auto()\n    SCHEME = auto()\n    AUTHORITY = auto()\n    PATH = auto()\n    PROTOCOL = auto()\n    STATUS = auto()\n</code></pre>"},{"location":"api/http2/#rnet.http2.SettingId","title":"SettingId","text":"<p>               Bases: <code>Enum</code></p> <p>An enum that lists all valid settings that can be sent in a SETTINGS frame.</p> <p>Each setting has a value that is a 32 bit unsigned integer (6.5.1.).</p> <p>See https://datatracker.ietf.org/doc/html/rfc9113#name-defined-settings.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass SettingId(Enum):\n    \"\"\"\n    An enum that lists all valid settings that can be sent in a SETTINGS frame.\n\n    Each setting has a value that is a 32 bit unsigned integer (6.5.1.).\n\n    See &lt;https://datatracker.ietf.org/doc/html/rfc9113#name-defined-settings&gt;.\n    \"\"\"\n\n    HEADER_TABLE_SIZE = auto()\n    \"\"\"\n    This setting allows the sender to inform the remote endpoint\n    of the maximum size of the compression table used to decode field blocks,\n    in units of octets. The encoder can select any size equal to or less than\n    this value by using signaling specific to the compression format inside\n    a field block (see [COMPRESSION]). The initial value is 4,096 octets.\n\n    [COMPRESSION]: &lt;https://datatracker.ietf.org/doc/html/rfc7541&gt;\n    \"\"\"\n\n    ENABLE_PUSH = auto()\n    \"\"\"\n    Enables or disables server push.\n    \"\"\"\n\n    MAX_CONCURRENT_STREAMS = auto()\n    \"\"\"\n    Specifies the maximum number of concurrent streams.\n    \"\"\"\n\n    INITIAL_WINDOW_SIZE = auto()\n    \"\"\"\n    Sets the initial stream-level flow control window size.\n    \"\"\"\n\n    MAX_FRAME_SIZE = auto()\n    \"\"\"\n    Indicates the largest acceptable frame payload size.\n    \"\"\"\n\n    MAX_HEADER_LIST_SIZE = auto()\n    \"\"\"\n    Advises the peer of the max field section size.\n    \"\"\"\n\n    ENABLE_CONNECT_PROTOCOL = auto()\n    \"\"\"\n    Enables support for the Extended CONNECT protocol.\n    \"\"\"\n\n    NO_RFC7540_PRIORITIES = auto()\n    \"\"\"\n    Disable RFC 7540 Stream Priorities.\n    [RFC 9218]: &lt;https://www.rfc-editor.org/rfc/rfc9218.html#section-2.1&gt;\n    \"\"\"\n</code></pre>"},{"location":"api/http2/#rnet.http2.SettingId.HEADER_TABLE_SIZE","title":"HEADER_TABLE_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HEADER_TABLE_SIZE = auto()\n</code></pre> <p>This setting allows the sender to inform the remote endpoint of the maximum size of the compression table used to decode field blocks, in units of octets. The encoder can select any size equal to or less than this value by using signaling specific to the compression format inside a field block (see COMPRESSION). The initial value is 4,096 octets.</p>"},{"location":"api/http2/#rnet.http2.SettingId.ENABLE_PUSH","title":"ENABLE_PUSH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENABLE_PUSH = auto()\n</code></pre> <p>Enables or disables server push.</p>"},{"location":"api/http2/#rnet.http2.SettingId.MAX_CONCURRENT_STREAMS","title":"MAX_CONCURRENT_STREAMS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_CONCURRENT_STREAMS = auto()\n</code></pre> <p>Specifies the maximum number of concurrent streams.</p>"},{"location":"api/http2/#rnet.http2.SettingId.INITIAL_WINDOW_SIZE","title":"INITIAL_WINDOW_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INITIAL_WINDOW_SIZE = auto()\n</code></pre> <p>Sets the initial stream-level flow control window size.</p>"},{"location":"api/http2/#rnet.http2.SettingId.MAX_FRAME_SIZE","title":"MAX_FRAME_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_FRAME_SIZE = auto()\n</code></pre> <p>Indicates the largest acceptable frame payload size.</p>"},{"location":"api/http2/#rnet.http2.SettingId.MAX_HEADER_LIST_SIZE","title":"MAX_HEADER_LIST_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_HEADER_LIST_SIZE = auto()\n</code></pre> <p>Advises the peer of the max field section size.</p>"},{"location":"api/http2/#rnet.http2.SettingId.ENABLE_CONNECT_PROTOCOL","title":"ENABLE_CONNECT_PROTOCOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENABLE_CONNECT_PROTOCOL = auto()\n</code></pre> <p>Enables support for the Extended CONNECT protocol.</p>"},{"location":"api/http2/#rnet.http2.SettingId.NO_RFC7540_PRIORITIES","title":"NO_RFC7540_PRIORITIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NO_RFC7540_PRIORITIES = auto()\n</code></pre> <p>Disable RFC 7540 Stream Priorities.</p>"},{"location":"api/http2/#rnet.http2.StreamId","title":"StreamId","text":"<p>A stream identifier, as described in Section 5.1.1 of RFC 7540.</p> <p>Streams are identified with an unsigned 31-bit integer. Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass StreamId:\n    \"\"\"\n    A stream identifier, as described in [Section 5.1.1] of RFC 7540.\n\n    Streams are identified with an unsigned 31-bit integer. Streams\n    initiated by a client MUST use odd-numbered stream identifiers; those\n    initiated by the server MUST use even-numbered stream identifiers.  A\n    stream identifier of zero (0x0) is used for connection control\n    messages; the stream identifier of zero cannot be used to establish a\n    new stream.\n\n    [Section 5.1.1]: https://tools.ietf.org/html/rfc7540#section-5.1.1\n    \"\"\"\n\n    ZERO: ClassVar[Self]\n    \"\"\"Stream ID 0.\"\"\"\n\n    MAX: ClassVar[Self]\n    \"\"\"The maximum allowed stream ID.\"\"\"\n\n    def __init__(self, src: int) -&gt; None:\n        \"\"\"\n        Create a new StreamId.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.StreamId.ZERO","title":"ZERO  <code>class-attribute</code>","text":"<pre><code>ZERO\n</code></pre> <p>Stream ID 0.</p>"},{"location":"api/http2/#rnet.http2.StreamId.MAX","title":"MAX  <code>class-attribute</code>","text":"<pre><code>MAX\n</code></pre> <p>The maximum allowed stream ID.</p>"},{"location":"api/http2/#rnet.http2.StreamId.__init__","title":"__init__","text":"<pre><code>__init__(src)\n</code></pre> <p>Create a new StreamId.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(self, src: int) -&gt; None:\n    \"\"\"\n    Create a new StreamId.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.StreamDependency","title":"StreamDependency","text":"<p>Represents a stream dependency in HTTP/2 priority frames.</p> <p>A stream dependency consists of three components: * A stream identifier that the stream depends on * A weight value between 0 and 255 (representing 1-256 in the protocol) * An exclusive flag indicating whether this is an exclusive dependency</p>"},{"location":"api/http2/#rnet.http2.StreamDependency--stream-dependencies","title":"Stream Dependencies","text":"<p>In HTTP/2, stream dependencies form a dependency tree where each stream can depend on another stream. This creates a priority hierarchy that helps determine the relative order in which streams should be processed.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass StreamDependency:\n    \"\"\"\n    Represents a stream dependency in HTTP/2 priority frames.\n\n    A stream dependency consists of three components:\n    * A stream identifier that the stream depends on\n    * A weight value between 0 and 255 (representing 1-256 in the protocol)\n    * An exclusive flag indicating whether this is an exclusive dependency\n\n    # Stream Dependencies\n\n    In HTTP/2, stream dependencies form a dependency tree where each stream\n    can depend on another stream. This creates a priority hierarchy that helps\n    determine the relative order in which streams should be processed.\n    \"\"\"\n\n    def __init__(\n        self, dependency_id: StreamId, weight: int, is_exclusive: bool\n    ) -&gt; None:\n        \"\"\"\n        Create a new StreamDependency.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.StreamDependency.__init__","title":"__init__","text":"<pre><code>__init__(dependency_id, weight, is_exclusive)\n</code></pre> <p>Create a new StreamDependency.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(\n    self, dependency_id: StreamId, weight: int, is_exclusive: bool\n) -&gt; None:\n    \"\"\"\n    Create a new StreamDependency.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.Priority","title":"Priority","text":"<p>Represents an HTTP/2 PRIORITY frame (type=0x2).</p> <p>The PRIORITY frame specifies the sender-advised priority of a stream, as described in RFC 7540 Section 5.3. It can be sent in any stream state, including idle or closed streams.</p> <p>A PRIORITY frame consists of: * The stream identifier whose priority is being set * A StreamDependency object describing the dependency and weight</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass Priority:\n    \"\"\"\n    Represents an HTTP/2 PRIORITY frame (type=0x2).\n\n    The PRIORITY frame specifies the sender-advised priority of a stream,\n    as described in RFC 7540 Section 5.3. It can be sent in any stream state,\n    including idle or closed streams.\n\n    A PRIORITY frame consists of:\n    * The stream identifier whose priority is being set\n    * A StreamDependency object describing the dependency and weight\n\n    [Section 5.3]: https://tools.ietf.org/html/rfc7540#section-5.3\n    \"\"\"\n\n    def __init__(self, stream_id: StreamId, dependency: StreamDependency) -&gt; None:\n        \"\"\"\n        Create a new Priority frame description.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.Priority.__init__","title":"__init__","text":"<pre><code>__init__(stream_id, dependency)\n</code></pre> <p>Create a new Priority frame description.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(self, stream_id: StreamId, dependency: StreamDependency) -&gt; None:\n    \"\"\"\n    Create a new Priority frame description.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.Priorities","title":"Priorities","text":"<p>A collection of HTTP/2 PRIORITY frames.</p> <p>The Priorities class maintains an ordered list of Priority frames, which can be used to represent and manage the stream dependency tree in HTTP/2. This is useful for pre-configuring stream priorities or sending multiple PRIORITY frames at once during connection setup or stream reprioritization.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass Priorities:\n    \"\"\"\n    A collection of HTTP/2 PRIORITY frames.\n\n    The Priorities class maintains an ordered list of Priority frames,\n    which can be used to represent and manage the stream dependency tree\n    in HTTP/2. This is useful for pre-configuring stream priorities or\n    sending multiple PRIORITY frames at once during connection setup or\n    stream reprioritization.\n    \"\"\"\n\n    def __init__(self, *priority: Priority) -&gt; None:\n        \"\"\"\n        Create a new Priorities instance.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.Priorities.__init__","title":"__init__","text":"<pre><code>__init__(*priority)\n</code></pre> <p>Create a new Priorities instance.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(self, *priority: Priority) -&gt; None:\n    \"\"\"\n    Create a new Priorities instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.PseudoOrder","title":"PseudoOrder","text":"<p>Represents the order of HTTP/2 pseudo-header fields in the header block.</p> <p>The PseudoOrder class maintains a list of PseudoId values that define the order in which pseudo-header fields should appear in an HTTP/2 HEADERS frame. This is important because the order of pseudo-headers is significant and must follow specific rules as defined in RFC 7540.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass PseudoOrder:\n    \"\"\"\n    Represents the order of HTTP/2 pseudo-header fields in the header block.\n\n    The PseudoOrder class maintains a list of PseudoId values that define\n    the order in which pseudo-header fields should appear in an HTTP/2\n    HEADERS frame. This is important because the order of pseudo-headers\n    is significant and must follow specific rules as defined in RFC 7540.\n    \"\"\"\n\n    def __init__(self, *pseudo_id: PseudoId) -&gt; None:\n        \"\"\"\n        Create a new PseudoOrder instance.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.PseudoOrder.__init__","title":"__init__","text":"<pre><code>__init__(*pseudo_id)\n</code></pre> <p>Create a new PseudoOrder instance.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(self, *pseudo_id: PseudoId) -&gt; None:\n    \"\"\"\n    Create a new PseudoOrder instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.SettingsOrder","title":"SettingsOrder","text":"<p>Represents the order of HTTP/2 settings parameters in the SETTINGS frame.</p> <p>The SettingsOrder class maintains a list of SettingId values that define the order in which settings parameters should appear in an HTTP/2 SETTINGS frame. While the order of settings is not strictly enforced by the protocol, having a consistent order can help with readability and debugging.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass SettingsOrder:\n    \"\"\"\n    Represents the order of HTTP/2 settings parameters in the SETTINGS frame.\n\n    The SettingsOrder class maintains a list of SettingId values that define\n    the order in which settings parameters should appear in an HTTP/2\n    SETTINGS frame. While the order of settings is not strictly enforced\n    by the protocol, having a consistent order can help with readability\n    and debugging.\n    \"\"\"\n\n    def __init__(self, *setting_id: SettingId) -&gt; None:\n        \"\"\"\n        Create a new SettingsOrder instance.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.SettingsOrder.__init__","title":"__init__","text":"<pre><code>__init__(*setting_id)\n</code></pre> <p>Create a new SettingsOrder instance.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(self, *setting_id: SettingId) -&gt; None:\n    \"\"\"\n    Create a new SettingsOrder instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.Params","title":"Params","text":"<p>               Bases: <code>TypedDict</code></p> <p>All parameters for HTTP/2 connections.</p> Source code in <code>rnet/http2.py</code> <pre><code>class Params(TypedDict):\n    \"\"\"\n    All parameters for HTTP/2 connections.\n    \"\"\"\n\n    initial_window_size: NotRequired[int]\n    \"\"\"\n    Initial window size for HTTP/2 streams.\n    \"\"\"\n\n    initial_connection_window_size: NotRequired[int]\n    \"\"\"\n    Initial connection-level window size.\n    \"\"\"\n\n    initial_max_send_streams: NotRequired[int]\n    \"\"\"\n    Initial maximum number of send streams.\n    \"\"\"\n\n    initial_stream_id: NotRequired[int]\n    \"\"\"\n    Initial stream ID for the connection.\n    \"\"\"\n\n    adaptive_window: NotRequired[bool]\n    \"\"\"\n    Whether to use adaptive flow control.\n    \"\"\"\n\n    max_frame_size: NotRequired[int]\n    \"\"\"\n    Maximum frame size to use for HTTP/2.\n    \"\"\"\n\n    max_header_list_size: NotRequired[int]\n    \"\"\"\n    Maximum size of the header list.\n    \"\"\"\n\n    header_table_size: NotRequired[int]\n    \"\"\"\n    Header table size for HPACK compression.\n    \"\"\"\n\n    max_concurrent_streams: NotRequired[int]\n    \"\"\"\n    Maximum concurrent streams from remote peer.\n    \"\"\"\n\n    keep_alive_interval: NotRequired[datetime.timedelta]\n    \"\"\"\n    Interval for HTTP/2 keep-alive ping frames.\n    \"\"\"\n\n    keep_alive_timeout: NotRequired[datetime.timedelta]\n    \"\"\"\n    Timeout for keep-alive ping acknowledgements.\n    \"\"\"\n\n    keep_alive_while_idle: NotRequired[bool]\n    \"\"\"\n    Whether keep-alive applies while idle.\n    \"\"\"\n\n    enable_push: NotRequired[bool]\n    \"\"\"\n    Whether to enable push promises.\n    \"\"\"\n\n    enable_connect_protocol: NotRequired[bool]\n    \"\"\"\n    Whether to enable the CONNECT protocol.\n    \"\"\"\n\n    no_rfc7540_priorities: NotRequired[bool]\n    \"\"\"\n    Whether to disable RFC 7540 Stream Priorities.\n    \"\"\"\n\n    max_concurrent_reset_streams: NotRequired[int]\n    \"\"\"\n    Max concurrent locally reset streams.\n    \"\"\"\n\n    max_send_buf_size: NotRequired[int]\n    \"\"\"\n    Maximum send buffer size for streams.\n    \"\"\"\n\n    max_pending_accept_reset_streams: NotRequired[int]\n    \"\"\"\n    Max pending accept reset streams.\n    \"\"\"\n\n    headers_stream_dependency: NotRequired[StreamDependency]\n    \"\"\"\n    Stream dependency for outgoing HEADERS.\n    \"\"\"\n\n    headers_pseudo_order: NotRequired[PseudoOrder]\n    \"\"\"\n    Order of pseudo-header fields in HEADERS.\n    \"\"\"\n\n    settings_order: NotRequired[SettingsOrder]\n    \"\"\"\n    Order of settings parameters in SETTINGS frame.\n    \"\"\"\n\n    priorities: NotRequired[Priorities]\n    \"\"\"\n    List of PRIORITY frames to send after connection.\n    \"\"\"\n</code></pre>"},{"location":"api/http2/#rnet.http2.Params.initial_window_size","title":"initial_window_size  <code>instance-attribute</code>","text":"<pre><code>initial_window_size\n</code></pre> <p>Initial window size for HTTP/2 streams.</p>"},{"location":"api/http2/#rnet.http2.Params.initial_connection_window_size","title":"initial_connection_window_size  <code>instance-attribute</code>","text":"<pre><code>initial_connection_window_size\n</code></pre> <p>Initial connection-level window size.</p>"},{"location":"api/http2/#rnet.http2.Params.initial_max_send_streams","title":"initial_max_send_streams  <code>instance-attribute</code>","text":"<pre><code>initial_max_send_streams\n</code></pre> <p>Initial maximum number of send streams.</p>"},{"location":"api/http2/#rnet.http2.Params.initial_stream_id","title":"initial_stream_id  <code>instance-attribute</code>","text":"<pre><code>initial_stream_id\n</code></pre> <p>Initial stream ID for the connection.</p>"},{"location":"api/http2/#rnet.http2.Params.adaptive_window","title":"adaptive_window  <code>instance-attribute</code>","text":"<pre><code>adaptive_window\n</code></pre> <p>Whether to use adaptive flow control.</p>"},{"location":"api/http2/#rnet.http2.Params.max_frame_size","title":"max_frame_size  <code>instance-attribute</code>","text":"<pre><code>max_frame_size\n</code></pre> <p>Maximum frame size to use for HTTP/2.</p>"},{"location":"api/http2/#rnet.http2.Params.max_header_list_size","title":"max_header_list_size  <code>instance-attribute</code>","text":"<pre><code>max_header_list_size\n</code></pre> <p>Maximum size of the header list.</p>"},{"location":"api/http2/#rnet.http2.Params.header_table_size","title":"header_table_size  <code>instance-attribute</code>","text":"<pre><code>header_table_size\n</code></pre> <p>Header table size for HPACK compression.</p>"},{"location":"api/http2/#rnet.http2.Params.max_concurrent_streams","title":"max_concurrent_streams  <code>instance-attribute</code>","text":"<pre><code>max_concurrent_streams\n</code></pre> <p>Maximum concurrent streams from remote peer.</p>"},{"location":"api/http2/#rnet.http2.Params.keep_alive_interval","title":"keep_alive_interval  <code>instance-attribute</code>","text":"<pre><code>keep_alive_interval\n</code></pre> <p>Interval for HTTP/2 keep-alive ping frames.</p>"},{"location":"api/http2/#rnet.http2.Params.keep_alive_timeout","title":"keep_alive_timeout  <code>instance-attribute</code>","text":"<pre><code>keep_alive_timeout\n</code></pre> <p>Timeout for keep-alive ping acknowledgements.</p>"},{"location":"api/http2/#rnet.http2.Params.keep_alive_while_idle","title":"keep_alive_while_idle  <code>instance-attribute</code>","text":"<pre><code>keep_alive_while_idle\n</code></pre> <p>Whether keep-alive applies while idle.</p>"},{"location":"api/http2/#rnet.http2.Params.enable_push","title":"enable_push  <code>instance-attribute</code>","text":"<pre><code>enable_push\n</code></pre> <p>Whether to enable push promises.</p>"},{"location":"api/http2/#rnet.http2.Params.enable_connect_protocol","title":"enable_connect_protocol  <code>instance-attribute</code>","text":"<pre><code>enable_connect_protocol\n</code></pre> <p>Whether to enable the CONNECT protocol.</p>"},{"location":"api/http2/#rnet.http2.Params.no_rfc7540_priorities","title":"no_rfc7540_priorities  <code>instance-attribute</code>","text":"<pre><code>no_rfc7540_priorities\n</code></pre> <p>Whether to disable RFC 7540 Stream Priorities.</p>"},{"location":"api/http2/#rnet.http2.Params.max_concurrent_reset_streams","title":"max_concurrent_reset_streams  <code>instance-attribute</code>","text":"<pre><code>max_concurrent_reset_streams\n</code></pre> <p>Max concurrent locally reset streams.</p>"},{"location":"api/http2/#rnet.http2.Params.max_send_buf_size","title":"max_send_buf_size  <code>instance-attribute</code>","text":"<pre><code>max_send_buf_size\n</code></pre> <p>Maximum send buffer size for streams.</p>"},{"location":"api/http2/#rnet.http2.Params.max_pending_accept_reset_streams","title":"max_pending_accept_reset_streams  <code>instance-attribute</code>","text":"<pre><code>max_pending_accept_reset_streams\n</code></pre> <p>Max pending accept reset streams.</p>"},{"location":"api/http2/#rnet.http2.Params.headers_stream_dependency","title":"headers_stream_dependency  <code>instance-attribute</code>","text":"<pre><code>headers_stream_dependency\n</code></pre> <p>Stream dependency for outgoing HEADERS.</p>"},{"location":"api/http2/#rnet.http2.Params.headers_pseudo_order","title":"headers_pseudo_order  <code>instance-attribute</code>","text":"<pre><code>headers_pseudo_order\n</code></pre> <p>Order of pseudo-header fields in HEADERS.</p>"},{"location":"api/http2/#rnet.http2.Params.settings_order","title":"settings_order  <code>instance-attribute</code>","text":"<pre><code>settings_order\n</code></pre> <p>Order of settings parameters in SETTINGS frame.</p>"},{"location":"api/http2/#rnet.http2.Params.priorities","title":"priorities  <code>instance-attribute</code>","text":"<pre><code>priorities\n</code></pre> <p>List of PRIORITY frames to send after connection.</p>"},{"location":"api/http2/#rnet.http2.Http2Options","title":"Http2Options","text":"<p>Configuration for an HTTP/2 connection.</p> <p>This struct defines various parameters to fine-tune the behavior of an HTTP/2 connection, including stream management, window sizes, frame limits, and header config.</p> Source code in <code>rnet/http2.py</code> <pre><code>@final\nclass Http2Options:\n    \"\"\"\n    Configuration for an HTTP/2 connection.\n\n    This struct defines various parameters to fine-tune the behavior of an HTTP/2 connection,\n    including stream management, window sizes, frame limits, and header config.\n    \"\"\"\n\n    def __init__(self, **kwargs: Unpack[Params]) -&gt; None:\n        \"\"\"\n        Create a new Http2Options instance.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/http2/#rnet.http2.Http2Options.__init__","title":"__init__","text":"<pre><code>__init__(**kwargs)\n</code></pre> <p>Create a new Http2Options instance.</p> Source code in <code>rnet/http2.py</code> <pre><code>def __init__(self, **kwargs: Unpack[Params]) -&gt; None:\n    \"\"\"\n    Create a new Http2Options instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/proxy/","title":"rnet.proxy","text":"<p>Proxy settings for HTTP, HTTPS, and SOCKS proxies.</p>"},{"location":"api/proxy/#rnet.proxy","title":"rnet.proxy","text":""},{"location":"api/proxy/#rnet.proxy.ProxyConfig","title":"ProxyConfig","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>rnet/proxy.py</code> <pre><code>class ProxyConfig(TypedDict):\n    username: NotRequired[str]\n    r\"\"\"Username for proxy authentication.\"\"\"\n\n    password: NotRequired[str]\n    r\"\"\"Password for proxy authentication.\"\"\"\n\n    custom_http_auth: NotRequired[str]\n    r\"\"\"Custom HTTP proxy authentication header value.\"\"\"\n\n    custom_http_headers: NotRequired[Dict[str, str] | HeaderMap]\n    r\"\"\"Custom HTTP proxy headers.\"\"\"\n\n    exclusion: NotRequired[str]\n    r\"\"\"List of domains to exclude from proxying.\"\"\"\n</code></pre>"},{"location":"api/proxy/#rnet.proxy.ProxyConfig.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username\n</code></pre> <p>Username for proxy authentication.</p>"},{"location":"api/proxy/#rnet.proxy.ProxyConfig.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password\n</code></pre> <p>Password for proxy authentication.</p>"},{"location":"api/proxy/#rnet.proxy.ProxyConfig.custom_http_auth","title":"custom_http_auth  <code>instance-attribute</code>","text":"<pre><code>custom_http_auth\n</code></pre> <p>Custom HTTP proxy authentication header value.</p>"},{"location":"api/proxy/#rnet.proxy.ProxyConfig.custom_http_headers","title":"custom_http_headers  <code>instance-attribute</code>","text":"<pre><code>custom_http_headers\n</code></pre> <p>Custom HTTP proxy headers.</p>"},{"location":"api/proxy/#rnet.proxy.ProxyConfig.exclusion","title":"exclusion  <code>instance-attribute</code>","text":"<pre><code>exclusion\n</code></pre> <p>List of domains to exclude from proxying.</p>"},{"location":"api/proxy/#rnet.proxy.Proxy","title":"Proxy","text":"<p>A proxy server for a request. Supports HTTP, HTTPS, SOCKS4, SOCKS4a, SOCKS5, and SOCKS5h protocols.</p> Source code in <code>rnet/proxy.py</code> <pre><code>@final\nclass Proxy:\n    r\"\"\"\n    A proxy server for a request.\n    Supports HTTP, HTTPS, SOCKS4, SOCKS4a, SOCKS5, and SOCKS5h protocols.\n    \"\"\"\n\n    @staticmethod\n    def http(url: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n        r\"\"\"\n        Creates a new HTTP proxy.\n\n        This method sets up a proxy server for HTTP requests.\n\n        # Examples\n\n        ```python\n        import rnet\n\n        proxy = rnet.Proxy.http(\"http://proxy.example.com\")\n        ```\n        \"\"\"\n        ...\n\n    @staticmethod\n    def https(url: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n        r\"\"\"\n        Creates a new HTTPS proxy.\n\n        This method sets up a proxy server for HTTPS requests.\n\n        # Examples\n\n        ```python\n        import rnet\n\n        proxy = rnet.Proxy.https(\"https://proxy.example.com\")\n        ```\n        \"\"\"\n        ...\n\n    @staticmethod\n    def all(url: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n        r\"\"\"\n        Creates a new proxy for all protocols.\n\n        This method sets up a proxy server for all types of requests (HTTP, HTTPS, etc.).\n\n        # Examples\n\n        ```python\n        import rnet\n\n        proxy = rnet.Proxy.all(\"https://proxy.example.com\")\n        ```\n        \"\"\"\n        ...\n\n    @staticmethod\n    def unix(path: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n        r\"\"\"\n        Creates a new UNIX socket proxy.\n\n        This method sets up a proxy server using a UNIX domain socket.\n\n        # Examples\n\n        ```python\n        import rnet\n\n        proxy = rnet.Proxy.unix(\"/var/run/docker.sock\")\n        ```\n        \"\"\"\n        ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/proxy/#rnet.proxy.Proxy.http","title":"http  <code>staticmethod</code>","text":"<pre><code>http(url, **kwargs)\n</code></pre> <p>Creates a new HTTP proxy.</p> <p>This method sets up a proxy server for HTTP requests.</p>"},{"location":"api/proxy/#rnet.proxy.Proxy.http--examples","title":"Examples","text":"<pre><code>import rnet\n\nproxy = rnet.Proxy.http(\"http://proxy.example.com\")\n</code></pre> Source code in <code>rnet/proxy.py</code> <pre><code>@staticmethod\ndef http(url: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n    r\"\"\"\n    Creates a new HTTP proxy.\n\n    This method sets up a proxy server for HTTP requests.\n\n    # Examples\n\n    ```python\n    import rnet\n\n    proxy = rnet.Proxy.http(\"http://proxy.example.com\")\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/proxy/#rnet.proxy.Proxy.https","title":"https  <code>staticmethod</code>","text":"<pre><code>https(url, **kwargs)\n</code></pre> <p>Creates a new HTTPS proxy.</p> <p>This method sets up a proxy server for HTTPS requests.</p>"},{"location":"api/proxy/#rnet.proxy.Proxy.https--examples","title":"Examples","text":"<pre><code>import rnet\n\nproxy = rnet.Proxy.https(\"https://proxy.example.com\")\n</code></pre> Source code in <code>rnet/proxy.py</code> <pre><code>@staticmethod\ndef https(url: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n    r\"\"\"\n    Creates a new HTTPS proxy.\n\n    This method sets up a proxy server for HTTPS requests.\n\n    # Examples\n\n    ```python\n    import rnet\n\n    proxy = rnet.Proxy.https(\"https://proxy.example.com\")\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/proxy/#rnet.proxy.Proxy.all","title":"all  <code>staticmethod</code>","text":"<pre><code>all(url, **kwargs)\n</code></pre> <p>Creates a new proxy for all protocols.</p> <p>This method sets up a proxy server for all types of requests (HTTP, HTTPS, etc.).</p>"},{"location":"api/proxy/#rnet.proxy.Proxy.all--examples","title":"Examples","text":"<pre><code>import rnet\n\nproxy = rnet.Proxy.all(\"https://proxy.example.com\")\n</code></pre> Source code in <code>rnet/proxy.py</code> <pre><code>@staticmethod\ndef all(url: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n    r\"\"\"\n    Creates a new proxy for all protocols.\n\n    This method sets up a proxy server for all types of requests (HTTP, HTTPS, etc.).\n\n    # Examples\n\n    ```python\n    import rnet\n\n    proxy = rnet.Proxy.all(\"https://proxy.example.com\")\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/proxy/#rnet.proxy.Proxy.unix","title":"unix  <code>staticmethod</code>","text":"<pre><code>unix(path, **kwargs)\n</code></pre> <p>Creates a new UNIX socket proxy.</p> <p>This method sets up a proxy server using a UNIX domain socket.</p>"},{"location":"api/proxy/#rnet.proxy.Proxy.unix--examples","title":"Examples","text":"<pre><code>import rnet\n\nproxy = rnet.Proxy.unix(\"/var/run/docker.sock\")\n</code></pre> Source code in <code>rnet/proxy.py</code> <pre><code>@staticmethod\ndef unix(path: str, **kwargs: Unpack[ProxyConfig]) -&gt; \"Proxy\":\n    r\"\"\"\n    Creates a new UNIX socket proxy.\n\n    This method sets up a proxy server using a UNIX domain socket.\n\n    # Examples\n\n    ```python\n    import rnet\n\n    proxy = rnet.Proxy.unix(\"/var/run/docker.sock\")\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/","title":"rnet.redirect","text":"<p>Configuration for handling HTTP redirects.</p>"},{"location":"api/redirect/#rnet.redirect","title":"rnet.redirect","text":""},{"location":"api/redirect/#rnet.redirect.Policy","title":"Policy","text":"<p>Represents the redirect policy for HTTP requests.</p> <p>The default value will catch redirect loops, and has a maximum of 10 redirects it will follow in a chain before returning an error.</p> Source code in <code>rnet/redirect.py</code> <pre><code>@final\nclass Policy:\n    \"\"\"\n    Represents the redirect policy for HTTP requests.\n\n    The default value will catch redirect loops, and has a maximum of 10\n    redirects it will follow in a chain before returning an error.\n    \"\"\"\n\n    \"\"\"\n    Create a default Policy instance.\n    \"\"\"\n\n    @staticmethod\n    def limited(max: int | None = None) -&gt; \"Policy\":\n        \"\"\"\n        Create a Policy with a maximum number of redirects.\n\n        An error will be returned if the max is reached.\n\n        Args:\n            max: Maximum number of redirects to follow\n\n        Returns:\n            Policy: A redirect policy with the specified limit\n\n        Example:\n            ```python\n            import rnet\n            from rnet import Client, redirect\n            policy = redirect.Policy.limited(5)\n            client = Client(redirect=policy)\n            ```\n        \"\"\"\n        ...\n\n    @staticmethod\n    def none() -&gt; \"Policy\":\n        \"\"\"\n        Create a Policy that does not follow any redirect.\n\n        Returns:\n            Policy: A redirect policy that doesn't follow redirects\n\n        Example:\n            ```python\n            from rnet import Client, redirect\n\n            policy = redirect.Policy.none()\n            client = Client(redirect=policy)\n            ```\n        \"\"\"\n        ...\n\n    @staticmethod\n    def custom(callback: Callable[[\"Attempt\"], \"Action\"]) -&gt; \"Policy\":\n        \"\"\"\n        Create a custom Policy using the passed function.\n\n        Args:\n            callback: A callable that takes an Attempt and returns an Action\n\n        Returns\n            Policy: A custom redirect policy\n\n        Example:\n            ```python\n            from rnet import Client, redirect\n\n            def policy(attempt: redirect.Attempt) -&gt; redirect.Action:\n                if len(attempt.previous) &gt; 5:\n                    return attempt.error(\"too many redirects\")\n                elif \"example.com\" in attempt.uri:\n                    return attempt.stop()\n                else:\n                    return attempt.follow()\n\n            policy = redirect.Policy.custom(policy)\n            client = Client(redirect=policy)\n            ```\n        \"\"\"\n        ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Policy.limited","title":"limited  <code>staticmethod</code>","text":"<pre><code>limited(max=None)\n</code></pre> <p>Create a Policy with a maximum number of redirects.</p> <p>An error will be returned if the max is reached.</p> <p>Parameters:</p> Name Type Description Default <code>max</code> <code>int | None</code> <p>Maximum number of redirects to follow</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Policy</code> <code>Policy</code> <p>A redirect policy with the specified limit</p> Example <pre><code>import rnet\nfrom rnet import Client, redirect\npolicy = redirect.Policy.limited(5)\nclient = Client(redirect=policy)\n</code></pre> Source code in <code>rnet/redirect.py</code> <pre><code>@staticmethod\ndef limited(max: int | None = None) -&gt; \"Policy\":\n    \"\"\"\n    Create a Policy with a maximum number of redirects.\n\n    An error will be returned if the max is reached.\n\n    Args:\n        max: Maximum number of redirects to follow\n\n    Returns:\n        Policy: A redirect policy with the specified limit\n\n    Example:\n        ```python\n        import rnet\n        from rnet import Client, redirect\n        policy = redirect.Policy.limited(5)\n        client = Client(redirect=policy)\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Policy.none","title":"none  <code>staticmethod</code>","text":"<pre><code>none()\n</code></pre> <p>Create a Policy that does not follow any redirect.</p> <p>Returns:</p> Name Type Description <code>Policy</code> <code>Policy</code> <p>A redirect policy that doesn't follow redirects</p> Example <pre><code>from rnet import Client, redirect\n\npolicy = redirect.Policy.none()\nclient = Client(redirect=policy)\n</code></pre> Source code in <code>rnet/redirect.py</code> <pre><code>@staticmethod\ndef none() -&gt; \"Policy\":\n    \"\"\"\n    Create a Policy that does not follow any redirect.\n\n    Returns:\n        Policy: A redirect policy that doesn't follow redirects\n\n    Example:\n        ```python\n        from rnet import Client, redirect\n\n        policy = redirect.Policy.none()\n        client = Client(redirect=policy)\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Policy.custom","title":"custom  <code>staticmethod</code>","text":"<pre><code>custom(callback)\n</code></pre> <p>Create a custom Policy using the passed function.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Attempt], Action]</code> <p>A callable that takes an Attempt and returns an Action</p> required <p>Returns     Policy: A custom redirect policy</p> Example <pre><code>from rnet import Client, redirect\n\ndef policy(attempt: redirect.Attempt) -&gt; redirect.Action:\n    if len(attempt.previous) &gt; 5:\n        return attempt.error(\"too many redirects\")\n    elif \"example.com\" in attempt.uri:\n        return attempt.stop()\n    else:\n        return attempt.follow()\n\npolicy = redirect.Policy.custom(policy)\nclient = Client(redirect=policy)\n</code></pre> Source code in <code>rnet/redirect.py</code> <pre><code>@staticmethod\ndef custom(callback: Callable[[\"Attempt\"], \"Action\"]) -&gt; \"Policy\":\n    \"\"\"\n    Create a custom Policy using the passed function.\n\n    Args:\n        callback: A callable that takes an Attempt and returns an Action\n\n    Returns\n        Policy: A custom redirect policy\n\n    Example:\n        ```python\n        from rnet import Client, redirect\n\n        def policy(attempt: redirect.Attempt) -&gt; redirect.Action:\n            if len(attempt.previous) &gt; 5:\n                return attempt.error(\"too many redirects\")\n            elif \"example.com\" in attempt.uri:\n                return attempt.stop()\n            else:\n                return attempt.follow()\n\n        policy = redirect.Policy.custom(policy)\n        client = Client(redirect=policy)\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Attempt","title":"Attempt","text":"<p>A type that holds information on the next request and previous requests in redirect chain.</p> Source code in <code>rnet/redirect.py</code> <pre><code>@final\nclass Attempt:\n    \"\"\"\n    A type that holds information on the next request and previous requests\n    in redirect chain.\n    \"\"\"\n\n    status: StatusCode\n    \"\"\"\n    The HTTP status code of the redirect response.\n    \"\"\"\n\n    headers: HeaderMap\n    \"\"\"\n    The headers of the redirect response.\n    \"\"\"\n\n    next: str\n    \"\"\"\n    The next URI to which the client is being redirected.\n    \"\"\"\n\n    previous: Sequence[str]\n    \"\"\"\n    The list of previous URIs in the redirect chain.\n    \"\"\"\n\n    def follow(self) -&gt; \"Action\":\n        \"\"\"\n        Returns an action meaning the client should follow the next URI.\n\n        Returns:\n            Action: An action to follow the redirect\n        \"\"\"\n        ...\n\n    def stop(self) -&gt; \"Action\":\n        \"\"\"\n        Returns an action meaning the client should not follow the next URI.\n\n        The 30x response will be returned as the result.\n\n        Returns:\n            Action: An action to stop following redirects\n        \"\"\"\n        ...\n\n    def error(self, message: str) -&gt; \"Action\":\n        \"\"\"\n        Returns an action failing the redirect with an error.\n\n        The error will be returned for the result of the sent request.\n\n        Args:\n            message: Error message\n\n        Returns:\n            Action: An action that will raise an error\n        \"\"\"\n        ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Attempt.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>The HTTP status code of the redirect response.</p>"},{"location":"api/redirect/#rnet.redirect.Attempt.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>The headers of the redirect response.</p>"},{"location":"api/redirect/#rnet.redirect.Attempt.next","title":"next  <code>instance-attribute</code>","text":"<pre><code>next\n</code></pre> <p>The next URI to which the client is being redirected.</p>"},{"location":"api/redirect/#rnet.redirect.Attempt.previous","title":"previous  <code>instance-attribute</code>","text":"<pre><code>previous\n</code></pre> <p>The list of previous URIs in the redirect chain.</p>"},{"location":"api/redirect/#rnet.redirect.Attempt.follow","title":"follow","text":"<pre><code>follow()\n</code></pre> <p>Returns an action meaning the client should follow the next URI.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>An action to follow the redirect</p> Source code in <code>rnet/redirect.py</code> <pre><code>def follow(self) -&gt; \"Action\":\n    \"\"\"\n    Returns an action meaning the client should follow the next URI.\n\n    Returns:\n        Action: An action to follow the redirect\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Attempt.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Returns an action meaning the client should not follow the next URI.</p> <p>The 30x response will be returned as the result.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>An action to stop following redirects</p> Source code in <code>rnet/redirect.py</code> <pre><code>def stop(self) -&gt; \"Action\":\n    \"\"\"\n    Returns an action meaning the client should not follow the next URI.\n\n    The 30x response will be returned as the result.\n\n    Returns:\n        Action: An action to stop following redirects\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Attempt.error","title":"error","text":"<pre><code>error(message)\n</code></pre> <p>Returns an action failing the redirect with an error.</p> <p>The error will be returned for the result of the sent request.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>An action that will raise an error</p> Source code in <code>rnet/redirect.py</code> <pre><code>def error(self, message: str) -&gt; \"Action\":\n    \"\"\"\n    Returns an action failing the redirect with an error.\n\n    The error will be returned for the result of the sent request.\n\n    Args:\n        message: Error message\n\n    Returns:\n        Action: An action that will raise an error\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.Action","title":"Action","text":"<p>An action to perform when a redirect status code is found.</p> <p>This class is typically created by calling methods on Attempt: - attempt.follow() - attempt.stop() - attempt.error(message)</p> Source code in <code>rnet/redirect.py</code> <pre><code>@final\nclass Action:\n    \"\"\"\n    An action to perform when a redirect status code is found.\n\n    This class is typically created by calling methods on Attempt:\n    - attempt.follow()\n    - attempt.stop()\n    - attempt.error(message)\n    \"\"\"\n\n    ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.History","title":"History","text":"<p>An entry in the redirect history.</p> Source code in <code>rnet/redirect.py</code> <pre><code>@final\nclass History:\n    \"\"\"\n    An entry in the redirect history.\n    \"\"\"\n\n    status: int\n    \"\"\"Get the status code of the redirect response.\"\"\"\n\n    url: str\n    \"\"\"Get the URL of the redirect response.\"\"\"\n\n    previous: str\n    \"\"\"Get the previous URL before the redirect response.\"\"\"\n\n    headers: HeaderMap\n    \"\"\"Get the headers of the redirect response.\"\"\"\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"api/redirect/#rnet.redirect.History.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>Get the status code of the redirect response.</p>"},{"location":"api/redirect/#rnet.redirect.History.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url\n</code></pre> <p>Get the URL of the redirect response.</p>"},{"location":"api/redirect/#rnet.redirect.History.previous","title":"previous  <code>instance-attribute</code>","text":"<pre><code>previous\n</code></pre> <p>Get the previous URL before the redirect response.</p>"},{"location":"api/redirect/#rnet.redirect.History.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers\n</code></pre> <p>Get the headers of the redirect response.</p>"},{"location":"api/tls/","title":"rnet.tls","text":"<p>TLS/SSL configuration including certificates, key logging, and fingerprinting.</p>"},{"location":"api/tls/#rnet.tls","title":"rnet.tls","text":"<p>TLS Utilities and Types</p> <p>This module provides types and utilities for configuring TLS (Transport Layer Security) in HTTP clients.</p>"},{"location":"api/tls/#rnet.tls.TlsVersion","title":"TlsVersion","text":"<p>               Bases: <code>Enum</code></p> <p>The TLS version.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass TlsVersion(Enum):\n    r\"\"\"\n    The TLS version.\n    \"\"\"\n\n    TLS_1_0 = auto()\n    TLS_1_1 = auto()\n    TLS_1_2 = auto()\n    TLS_1_3 = auto()\n</code></pre>"},{"location":"api/tls/#rnet.tls.AlpnProtocol","title":"AlpnProtocol","text":"<p>               Bases: <code>Enum</code></p> <p>A TLS ALPN protocol.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass AlpnProtocol(Enum):\n    \"\"\"\n    A TLS ALPN protocol.\n    \"\"\"\n\n    HTTP1 = auto()\n    HTTP2 = auto()\n    HTTP3 = auto()\n</code></pre>"},{"location":"api/tls/#rnet.tls.AlpsProtocol","title":"AlpsProtocol","text":"<p>               Bases: <code>Enum</code></p> <p>Application-layer protocol settings for HTTP/1.1 and HTTP/2.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass AlpsProtocol(Enum):\n    \"\"\"\n    Application-layer protocol settings for HTTP/1.1 and HTTP/2.\n    \"\"\"\n\n    HTTP1 = auto()\n    HTTP2 = auto()\n    HTTP3 = auto()\n</code></pre>"},{"location":"api/tls/#rnet.tls.CertificateCompressionAlgorithm","title":"CertificateCompressionAlgorithm","text":"<p>               Bases: <code>Enum</code></p> <p>IANA assigned identifier of compression algorithm. See https://www.rfc-editor.org/rfc/rfc8879.html#name-compression-algorithms</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass CertificateCompressionAlgorithm(Enum):\n    \"\"\"\n    IANA assigned identifier of compression algorithm.\n    See https://www.rfc-editor.org/rfc/rfc8879.html#name-compression-algorithms\n    \"\"\"\n\n    ZLIB = auto()\n    BROTLI = auto()\n    ZSTD = auto()\n</code></pre>"},{"location":"api/tls/#rnet.tls.ExtensionType","title":"ExtensionType","text":"<p>               Bases: <code>Enum</code></p> <p>A TLS extension type.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass ExtensionType(Enum):\n    \"\"\"\n    A TLS extension type.\n    \"\"\"\n\n    SERVER_NAME = auto()\n    STATUS_REQUEST = auto()\n    EC_POINT_FORMATS = auto()\n    SIGNATURE_ALGORITHMS = auto()\n    SRTP = auto()\n    APPLICATION_LAYER_PROTOCOL_NEGOTIATION = auto()\n    PADDING = auto()\n    EXTENDED_MASTER_SECRET = auto()\n    QUIC_TRANSPORT_PARAMETERS_LEGACY = auto()\n    QUIC_TRANSPORT_PARAMETERS_STANDARD = auto()\n    CERT_COMPRESSION = auto()\n    SESSION_TICKET = auto()\n    SUPPORTED_GROUPS = auto()\n    PRE_SHARED_KEY = auto()\n    EARLY_DATA = auto()\n    SUPPORTED_VERSIONS = auto()\n    COOKIE = auto()\n    PSK_KEY_EXCHANGE_MODES = auto()\n    CERTIFICATE_AUTHORITIES = auto()\n    SIGNATURE_ALGORITHMS_CERT = auto()\n    KEY_SHARE = auto()\n    RENEGOTIATE = auto()\n    DELEGATED_CREDENTIAL = auto()\n    APPLICATION_SETTINGS = auto()\n    APPLICATION_SETTINGS_NEW = auto()\n    ENCRYPTED_CLIENT_HELLO = auto()\n    CERTIFICATE_TIMESTAMP = auto()\n    NEXT_PROTO_NEG = auto()\n    CHANNEL_ID = auto()\n    RECORD_SIZE_LIMIT = auto()\n</code></pre>"},{"location":"api/tls/#rnet.tls.Identity","title":"Identity","text":"<p>Represents a private key and X509 cert as a client certificate.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass Identity:\n    \"\"\"\n    Represents a private key and X509 cert as a client certificate.\n    \"\"\"\n\n    @staticmethod\n    def from_pkcs12_der(buf: bytes, pass_: str) -&gt; \"Identity\":\n        \"\"\"\n        Parses a DER-formatted PKCS #12 archive, using the specified password to decrypt the key.\n\n        The archive should contain a leaf certificate and its private key, as well any intermediate\n        certificates that allow clients to build a chain to a trusted root.\n        The chain certificates should be in order from the leaf certificate towards the root.\n\n        PKCS #12 archives typically have the file extension `.p12` or `.pfx`, and can be created\n        with the OpenSSL `pkcs12` tool:\n\n            openssl pkcs12 -export -out identity.pfx -inkey key.pem -in cert.pem -certfile chain_certs.pem\n        \"\"\"\n        ...\n\n    @staticmethod\n    def from_pkcs8_pem(buf: bytes, key: bytes) -&gt; \"Identity\":\n        \"\"\"\n        Parses a chain of PEM encoded X509 certificates, with the leaf certificate first.\n        `key` is a PEM encoded PKCS #8 formatted private key for the leaf certificate.\n\n        The certificate chain should contain any intermediate certificates that should be sent to\n        clients to allow them to build a chain to a trusted root.\n\n        A certificate chain here means a series of PEM encoded certificates concatenated together.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.Identity.from_pkcs12_der","title":"from_pkcs12_der  <code>staticmethod</code>","text":"<pre><code>from_pkcs12_der(buf, pass_)\n</code></pre> <p>Parses a DER-formatted PKCS #12 archive, using the specified password to decrypt the key.</p> <p>The archive should contain a leaf certificate and its private key, as well any intermediate certificates that allow clients to build a chain to a trusted root. The chain certificates should be in order from the leaf certificate towards the root.</p> <p>PKCS #12 archives typically have the file extension <code>.p12</code> or <code>.pfx</code>, and can be created with the OpenSSL <code>pkcs12</code> tool:</p> <pre><code>openssl pkcs12 -export -out identity.pfx -inkey key.pem -in cert.pem -certfile chain_certs.pem\n</code></pre> Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef from_pkcs12_der(buf: bytes, pass_: str) -&gt; \"Identity\":\n    \"\"\"\n    Parses a DER-formatted PKCS #12 archive, using the specified password to decrypt the key.\n\n    The archive should contain a leaf certificate and its private key, as well any intermediate\n    certificates that allow clients to build a chain to a trusted root.\n    The chain certificates should be in order from the leaf certificate towards the root.\n\n    PKCS #12 archives typically have the file extension `.p12` or `.pfx`, and can be created\n    with the OpenSSL `pkcs12` tool:\n\n        openssl pkcs12 -export -out identity.pfx -inkey key.pem -in cert.pem -certfile chain_certs.pem\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.Identity.from_pkcs8_pem","title":"from_pkcs8_pem  <code>staticmethod</code>","text":"<pre><code>from_pkcs8_pem(buf, key)\n</code></pre> <p>Parses a chain of PEM encoded X509 certificates, with the leaf certificate first. <code>key</code> is a PEM encoded PKCS #8 formatted private key for the leaf certificate.</p> <p>The certificate chain should contain any intermediate certificates that should be sent to clients to allow them to build a chain to a trusted root.</p> <p>A certificate chain here means a series of PEM encoded certificates concatenated together.</p> Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef from_pkcs8_pem(buf: bytes, key: bytes) -&gt; \"Identity\":\n    \"\"\"\n    Parses a chain of PEM encoded X509 certificates, with the leaf certificate first.\n    `key` is a PEM encoded PKCS #8 formatted private key for the leaf certificate.\n\n    The certificate chain should contain any intermediate certificates that should be sent to\n    clients to allow them to build a chain to a trusted root.\n\n    A certificate chain here means a series of PEM encoded certificates concatenated together.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.CertStore","title":"CertStore","text":"<p>Represents a certificate store for verifying TLS connections.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass CertStore:\n    \"\"\"\n    Represents a certificate store for verifying TLS connections.\n    \"\"\"\n\n    def __init__(\n        self,\n        der_certs: Sequence[bytes] | None = None,\n        pem_certs: Sequence[str] | None = None,\n        default_paths: bool | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Creates a new CertStore.\n\n        Args:\n            der_certs: Optional list of DER-encoded certificates (as bytes).\n            pem_certs: Optional list of PEM-encoded certificates (as str).\n            default_paths: If True, use system default certificate paths.\n        \"\"\"\n        ...\n\n    @staticmethod\n    def from_der_certs(certs: Sequence[bytes]) -&gt; \"CertStore\":\n        \"\"\"\n        Creates a CertStore from a collection of DER-encoded certificates.\n\n        Args:\n            certs: List of DER-encoded certificates (as bytes).\n        \"\"\"\n        ...\n\n    @staticmethod\n    def from_pem_certs(certs: Sequence[str]) -&gt; \"CertStore\":\n        \"\"\"\n        Creates a CertStore from a collection of PEM-encoded certificates.\n\n        Args:\n            certs: List of PEM-encoded certificates (as str).\n        \"\"\"\n        ...\n\n    @staticmethod\n    def from_pem_stack(certs: bytes) -&gt; \"CertStore\":\n        \"\"\"\n        Creates a CertStore from a PEM-encoded certificate stack.\n\n        Args:\n            certs: PEM-encoded certificate stack (as bytes).\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.CertStore.__init__","title":"__init__","text":"<pre><code>__init__(der_certs=None, pem_certs=None, default_paths=None)\n</code></pre> <p>Creates a new CertStore.</p> <p>Parameters:</p> Name Type Description Default <code>der_certs</code> <code>Sequence[bytes] | None</code> <p>Optional list of DER-encoded certificates (as bytes).</p> <code>None</code> <code>pem_certs</code> <code>Sequence[str] | None</code> <p>Optional list of PEM-encoded certificates (as str).</p> <code>None</code> <code>default_paths</code> <code>bool | None</code> <p>If True, use system default certificate paths.</p> <code>None</code> Source code in <code>rnet/tls.py</code> <pre><code>def __init__(\n    self,\n    der_certs: Sequence[bytes] | None = None,\n    pem_certs: Sequence[str] | None = None,\n    default_paths: bool | None = None,\n) -&gt; None:\n    \"\"\"\n    Creates a new CertStore.\n\n    Args:\n        der_certs: Optional list of DER-encoded certificates (as bytes).\n        pem_certs: Optional list of PEM-encoded certificates (as str).\n        default_paths: If True, use system default certificate paths.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.CertStore.from_der_certs","title":"from_der_certs  <code>staticmethod</code>","text":"<pre><code>from_der_certs(certs)\n</code></pre> <p>Creates a CertStore from a collection of DER-encoded certificates.</p> <p>Parameters:</p> Name Type Description Default <code>certs</code> <code>Sequence[bytes]</code> <p>List of DER-encoded certificates (as bytes).</p> required Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef from_der_certs(certs: Sequence[bytes]) -&gt; \"CertStore\":\n    \"\"\"\n    Creates a CertStore from a collection of DER-encoded certificates.\n\n    Args:\n        certs: List of DER-encoded certificates (as bytes).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.CertStore.from_pem_certs","title":"from_pem_certs  <code>staticmethod</code>","text":"<pre><code>from_pem_certs(certs)\n</code></pre> <p>Creates a CertStore from a collection of PEM-encoded certificates.</p> <p>Parameters:</p> Name Type Description Default <code>certs</code> <code>Sequence[str]</code> <p>List of PEM-encoded certificates (as str).</p> required Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef from_pem_certs(certs: Sequence[str]) -&gt; \"CertStore\":\n    \"\"\"\n    Creates a CertStore from a collection of PEM-encoded certificates.\n\n    Args:\n        certs: List of PEM-encoded certificates (as str).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.CertStore.from_pem_stack","title":"from_pem_stack  <code>staticmethod</code>","text":"<pre><code>from_pem_stack(certs)\n</code></pre> <p>Creates a CertStore from a PEM-encoded certificate stack.</p> <p>Parameters:</p> Name Type Description Default <code>certs</code> <code>bytes</code> <p>PEM-encoded certificate stack (as bytes).</p> required Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef from_pem_stack(certs: bytes) -&gt; \"CertStore\":\n    \"\"\"\n    Creates a CertStore from a PEM-encoded certificate stack.\n\n    Args:\n        certs: PEM-encoded certificate stack (as bytes).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.KeyLog","title":"KeyLog","text":"<p>Specifies the intent for a (TLS) keylogger to be used in a client or server configuration.</p> <p>This type allows you to control how TLS session keys are logged for debugging or analysis. You can either use the default environment variable (SSLKEYLOGFILE) or specify a file path directly. This is useful for tools like Wireshark that can decrypt TLS traffic if provided with the correct session keys.</p> Static Methods <p>environment() -&gt; KeyLog     Use the SSLKEYLOGFILE environment variable for key logging. file(path: Path) -&gt; KeyLog     Log keys to the specified file path.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass KeyLog:\n    \"\"\"\n    Specifies the intent for a (TLS) keylogger to be used in a client or server configuration.\n\n    This type allows you to control how TLS session keys are logged for debugging or analysis.\n    You can either use the default environment variable (SSLKEYLOGFILE) or specify a file path\n    directly. This is useful for tools like Wireshark that can decrypt TLS traffic if provided\n    with the correct session keys.\n\n    Static Methods:\n        environment() -&gt; KeyLog\n            Use the SSLKEYLOGFILE environment variable for key logging.\n        file(path: Path) -&gt; KeyLog\n            Log keys to the specified file path.\n    \"\"\"\n\n    @staticmethod\n    def environment() -&gt; \"KeyLog\":\n        \"\"\"\n        Use the SSLKEYLOGFILE environment variable for key logging.\n        \"\"\"\n        ...\n\n    @staticmethod\n    def file(path: Path | str) -&gt; \"KeyLog\":\n        \"\"\"\n        Log keys to the specified file path.\n\n        Args:\n            path: The file path to log TLS keys to.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.KeyLog.environment","title":"environment  <code>staticmethod</code>","text":"<pre><code>environment()\n</code></pre> <p>Use the SSLKEYLOGFILE environment variable for key logging.</p> Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef environment() -&gt; \"KeyLog\":\n    \"\"\"\n    Use the SSLKEYLOGFILE environment variable for key logging.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.KeyLog.file","title":"file  <code>staticmethod</code>","text":"<pre><code>file(path)\n</code></pre> <p>Log keys to the specified file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The file path to log TLS keys to.</p> required Source code in <code>rnet/tls.py</code> <pre><code>@staticmethod\ndef file(path: Path | str) -&gt; \"KeyLog\":\n    \"\"\"\n    Log keys to the specified file path.\n\n    Args:\n        path: The file path to log TLS keys to.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.Params","title":"Params","text":"<p>               Bases: <code>TypedDict</code></p> <p>All parameters for TLS connections.</p> Source code in <code>rnet/tls.py</code> <pre><code>class Params(TypedDict):\n    \"\"\"\n    All parameters for TLS connections.\n    \"\"\"\n\n    alpn_protocols: NotRequired[Sequence[AlpnProtocol]]\n    \"\"\"\n    Application-Layer Protocol Negotiation (RFC 7301).\n\n    Specifies which application protocols (e.g., HTTP/2, HTTP/1.1) may be negotiated\n    over a single TLS connection.\n    \"\"\"\n\n    alps_protocols: NotRequired[Sequence[AlpsProtocol]]\n    \"\"\"\n    Application-Layer Protocol Settings (ALPS).\n\n    Enables exchanging application-layer settings during the handshake\n    for protocols negotiated via ALPN.\n    \"\"\"\n\n    alps_use_new_codepoint: NotRequired[bool]\n    \"\"\"\n    Whether to use an alternative ALPS codepoint for compatibility.\n\n    Useful when larger ALPS payloads are required.\n    \"\"\"\n\n    session_ticket: NotRequired[bool]\n    \"\"\"\n    Enables TLS Session Tickets (RFC 5077).\n\n    Allows session resumption without requiring server-side state.\n    \"\"\"\n\n    min_tls_version: NotRequired[TlsVersion]\n    \"\"\"\n    Minimum TLS version allowed for the connection.\n    \"\"\"\n\n    max_tls_version: NotRequired[TlsVersion]\n    \"\"\"\n    Maximum TLS version allowed for the connection.\n    \"\"\"\n\n    pre_shared_key: NotRequired[bool]\n    \"\"\"\n    Enables Pre-Shared Key (PSK) cipher suites (RFC 4279).\n\n    Authentication relies on out-of-band pre-shared keys instead of certificates.\n    \"\"\"\n\n    enable_ech_grease: NotRequired[bool]\n    \"\"\"\n    Controls whether to send a GREASE Encrypted ClientHello (ECH) extension\n    when no supported ECH configuration is available.\n\n    GREASE prevents protocol ossification by sending unknown extensions.\n    \"\"\"\n\n    permute_extensions: NotRequired[bool]\n    \"\"\"\n    Controls whether ClientHello extensions should be permuted.\n    \"\"\"\n\n    grease_enabled: NotRequired[bool]\n    \"\"\"\n    Controls whether GREASE extensions (RFC 8701) are enabled in general.\n    \"\"\"\n\n    enable_ocsp_stapling: NotRequired[bool]\n    \"\"\"\n    Enables OCSP stapling for the connection.\n    \"\"\"\n\n    enable_signed_cert_timestamps: NotRequired[bool]\n    \"\"\"\n    Enables Signed Certificate Timestamps (SCT).\n    \"\"\"\n\n    record_size_limit: NotRequired[int]\n    \"\"\"\n    Sets the maximum TLS record size.\n    \"\"\"\n\n    psk_skip_session_ticket: NotRequired[bool]\n    \"\"\"\n    Whether to skip session tickets when using PSK.\n    \"\"\"\n\n    key_shares_limit: NotRequired[int]\n    \"\"\"\n    Maximum number of key shares to include in ClientHello.\n    \"\"\"\n\n    psk_dhe_ke: NotRequired[bool]\n    \"\"\"\n    Enables PSK with (EC)DHE key establishment (`psk_dhe_ke`).\n    \"\"\"\n\n    renegotiation: NotRequired[bool]\n    \"\"\"\n    Enables TLS renegotiation by sending the `renegotiation_info` extension.\n    \"\"\"\n\n    delegated_credentials: NotRequired[str]\n    \"\"\"\n    Delegated Credentials (RFC 9345).\n\n    Allows TLS 1.3 endpoints to use temporary delegated credentials\n    for authentication with reduced long-term key exposure.\n    \"\"\"\n\n    curves_list: NotRequired[str]\n    \"\"\"\n    List of supported elliptic curves.\n    \"\"\"\n\n    cipher_list: NotRequired[str]\n    \"\"\"\n    Cipher suite configuration string.\n\n    Uses BoringSSL's mini-language to select, enable, and prioritize ciphers.\n    \"\"\"\n\n    sigalgs_list: NotRequired[str]\n    \"\"\"\n    List of supported signature algorithms.\n    \"\"\"\n\n    certificate_compression_algorithms: NotRequired[\n        Sequence[CertificateCompressionAlgorithm]\n    ]\n    \"\"\"\n    Supported certificate compression algorithms (RFC 8879).\n    \"\"\"\n\n    extension_permutation: NotRequired[Sequence[ExtensionType]]\n    \"\"\"\n    Supported TLS extensions, used for extension ordering/permutation.\n    \"\"\"\n\n    aes_hw_override: NotRequired[bool]\n    \"\"\"\n    Overrides AES hardware acceleration.\n    \"\"\"\n\n    random_aes_hw_override: NotRequired[bool]\n    \"\"\"\n    Overrides the random AES hardware acceleration.\n    \"\"\"\n\n    preserve_tls13_cipher_list: NotRequired[bool]\n    \"\"\"\n    Sets whether to preserve the TLS 1.3 cipher list as configured by cipher_list.\n\n    By default, BoringSSL does not preserve the TLS 1.3 cipher list. When this option is disabled\n    (the default), BoringSSL uses its internal default TLS 1.3 cipher suites in its default order,\n    regardless of what is set via cipher_list.\n\n    When enabled, this option ensures that the TLS 1.3 cipher suites explicitly set via\n    cipher_list are retained in their original order, without being reordered or\n    modified by BoringSSL's internal logic. This is useful for maintaining specific cipher suite\n    priorities for TLS 1.3. Note that if cipher_list does not include any TLS 1.3\n    cipher suites, BoringSSL will still fall back to its default TLS 1.3 cipher suites and order.\n    \"\"\"\n</code></pre>"},{"location":"api/tls/#rnet.tls.Params.alpn_protocols","title":"alpn_protocols  <code>instance-attribute</code>","text":"<pre><code>alpn_protocols\n</code></pre> <p>Application-Layer Protocol Negotiation (RFC 7301).</p> <p>Specifies which application protocols (e.g., HTTP/2, HTTP/1.1) may be negotiated over a single TLS connection.</p>"},{"location":"api/tls/#rnet.tls.Params.alps_protocols","title":"alps_protocols  <code>instance-attribute</code>","text":"<pre><code>alps_protocols\n</code></pre> <p>Application-Layer Protocol Settings (ALPS).</p> <p>Enables exchanging application-layer settings during the handshake for protocols negotiated via ALPN.</p>"},{"location":"api/tls/#rnet.tls.Params.alps_use_new_codepoint","title":"alps_use_new_codepoint  <code>instance-attribute</code>","text":"<pre><code>alps_use_new_codepoint\n</code></pre> <p>Whether to use an alternative ALPS codepoint for compatibility.</p> <p>Useful when larger ALPS payloads are required.</p>"},{"location":"api/tls/#rnet.tls.Params.session_ticket","title":"session_ticket  <code>instance-attribute</code>","text":"<pre><code>session_ticket\n</code></pre> <p>Enables TLS Session Tickets (RFC 5077).</p> <p>Allows session resumption without requiring server-side state.</p>"},{"location":"api/tls/#rnet.tls.Params.min_tls_version","title":"min_tls_version  <code>instance-attribute</code>","text":"<pre><code>min_tls_version\n</code></pre> <p>Minimum TLS version allowed for the connection.</p>"},{"location":"api/tls/#rnet.tls.Params.max_tls_version","title":"max_tls_version  <code>instance-attribute</code>","text":"<pre><code>max_tls_version\n</code></pre> <p>Maximum TLS version allowed for the connection.</p>"},{"location":"api/tls/#rnet.tls.Params.pre_shared_key","title":"pre_shared_key  <code>instance-attribute</code>","text":"<pre><code>pre_shared_key\n</code></pre> <p>Enables Pre-Shared Key (PSK) cipher suites (RFC 4279).</p> <p>Authentication relies on out-of-band pre-shared keys instead of certificates.</p>"},{"location":"api/tls/#rnet.tls.Params.enable_ech_grease","title":"enable_ech_grease  <code>instance-attribute</code>","text":"<pre><code>enable_ech_grease\n</code></pre> <p>Controls whether to send a GREASE Encrypted ClientHello (ECH) extension when no supported ECH configuration is available.</p> <p>GREASE prevents protocol ossification by sending unknown extensions.</p>"},{"location":"api/tls/#rnet.tls.Params.permute_extensions","title":"permute_extensions  <code>instance-attribute</code>","text":"<pre><code>permute_extensions\n</code></pre> <p>Controls whether ClientHello extensions should be permuted.</p>"},{"location":"api/tls/#rnet.tls.Params.grease_enabled","title":"grease_enabled  <code>instance-attribute</code>","text":"<pre><code>grease_enabled\n</code></pre> <p>Controls whether GREASE extensions (RFC 8701) are enabled in general.</p>"},{"location":"api/tls/#rnet.tls.Params.enable_ocsp_stapling","title":"enable_ocsp_stapling  <code>instance-attribute</code>","text":"<pre><code>enable_ocsp_stapling\n</code></pre> <p>Enables OCSP stapling for the connection.</p>"},{"location":"api/tls/#rnet.tls.Params.enable_signed_cert_timestamps","title":"enable_signed_cert_timestamps  <code>instance-attribute</code>","text":"<pre><code>enable_signed_cert_timestamps\n</code></pre> <p>Enables Signed Certificate Timestamps (SCT).</p>"},{"location":"api/tls/#rnet.tls.Params.record_size_limit","title":"record_size_limit  <code>instance-attribute</code>","text":"<pre><code>record_size_limit\n</code></pre> <p>Sets the maximum TLS record size.</p>"},{"location":"api/tls/#rnet.tls.Params.psk_skip_session_ticket","title":"psk_skip_session_ticket  <code>instance-attribute</code>","text":"<pre><code>psk_skip_session_ticket\n</code></pre> <p>Whether to skip session tickets when using PSK.</p>"},{"location":"api/tls/#rnet.tls.Params.key_shares_limit","title":"key_shares_limit  <code>instance-attribute</code>","text":"<pre><code>key_shares_limit\n</code></pre> <p>Maximum number of key shares to include in ClientHello.</p>"},{"location":"api/tls/#rnet.tls.Params.psk_dhe_ke","title":"psk_dhe_ke  <code>instance-attribute</code>","text":"<pre><code>psk_dhe_ke\n</code></pre> <p>Enables PSK with (EC)DHE key establishment (<code>psk_dhe_ke</code>).</p>"},{"location":"api/tls/#rnet.tls.Params.renegotiation","title":"renegotiation  <code>instance-attribute</code>","text":"<pre><code>renegotiation\n</code></pre> <p>Enables TLS renegotiation by sending the <code>renegotiation_info</code> extension.</p>"},{"location":"api/tls/#rnet.tls.Params.delegated_credentials","title":"delegated_credentials  <code>instance-attribute</code>","text":"<pre><code>delegated_credentials\n</code></pre> <p>Delegated Credentials (RFC 9345).</p> <p>Allows TLS 1.3 endpoints to use temporary delegated credentials for authentication with reduced long-term key exposure.</p>"},{"location":"api/tls/#rnet.tls.Params.curves_list","title":"curves_list  <code>instance-attribute</code>","text":"<pre><code>curves_list\n</code></pre> <p>List of supported elliptic curves.</p>"},{"location":"api/tls/#rnet.tls.Params.cipher_list","title":"cipher_list  <code>instance-attribute</code>","text":"<pre><code>cipher_list\n</code></pre> <p>Cipher suite configuration string.</p> <p>Uses BoringSSL's mini-language to select, enable, and prioritize ciphers.</p>"},{"location":"api/tls/#rnet.tls.Params.sigalgs_list","title":"sigalgs_list  <code>instance-attribute</code>","text":"<pre><code>sigalgs_list\n</code></pre> <p>List of supported signature algorithms.</p>"},{"location":"api/tls/#rnet.tls.Params.certificate_compression_algorithms","title":"certificate_compression_algorithms  <code>instance-attribute</code>","text":"<pre><code>certificate_compression_algorithms\n</code></pre> <p>Supported certificate compression algorithms (RFC 8879).</p>"},{"location":"api/tls/#rnet.tls.Params.extension_permutation","title":"extension_permutation  <code>instance-attribute</code>","text":"<pre><code>extension_permutation\n</code></pre> <p>Supported TLS extensions, used for extension ordering/permutation.</p>"},{"location":"api/tls/#rnet.tls.Params.aes_hw_override","title":"aes_hw_override  <code>instance-attribute</code>","text":"<pre><code>aes_hw_override\n</code></pre> <p>Overrides AES hardware acceleration.</p>"},{"location":"api/tls/#rnet.tls.Params.random_aes_hw_override","title":"random_aes_hw_override  <code>instance-attribute</code>","text":"<pre><code>random_aes_hw_override\n</code></pre> <p>Overrides the random AES hardware acceleration.</p>"},{"location":"api/tls/#rnet.tls.Params.preserve_tls13_cipher_list","title":"preserve_tls13_cipher_list  <code>instance-attribute</code>","text":"<pre><code>preserve_tls13_cipher_list\n</code></pre> <p>Sets whether to preserve the TLS 1.3 cipher list as configured by cipher_list.</p> <p>By default, BoringSSL does not preserve the TLS 1.3 cipher list. When this option is disabled (the default), BoringSSL uses its internal default TLS 1.3 cipher suites in its default order, regardless of what is set via cipher_list.</p> <p>When enabled, this option ensures that the TLS 1.3 cipher suites explicitly set via cipher_list are retained in their original order, without being reordered or modified by BoringSSL's internal logic. This is useful for maintaining specific cipher suite priorities for TLS 1.3. Note that if cipher_list does not include any TLS 1.3 cipher suites, BoringSSL will still fall back to its default TLS 1.3 cipher suites and order.</p>"},{"location":"api/tls/#rnet.tls.TlsOptions","title":"TlsOptions","text":"<p>TLS connection configuration options.</p> <p>This struct provides fine-grained control over the behavior of TLS connections, including:  - Protocol negotiation (ALPN, ALPS, TLS versions)  - Session management (tickets, PSK, key shares)  - Security &amp; privacy (OCSP, GREASE, ECH, delegated credentials)  - Performance tuning (record size, cipher preferences, hardware overrides)</p> <p>All fields are optional or have defaults. See each field for details.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass TlsOptions:\n    \"\"\"\n    TLS connection configuration options.\n\n    This struct provides fine-grained control over the behavior of TLS\n    connections, including:\n     - **Protocol negotiation** (ALPN, ALPS, TLS versions)\n     - **Session management** (tickets, PSK, key shares)\n     - **Security &amp; privacy** (OCSP, GREASE, ECH, delegated credentials)\n     - **Performance tuning** (record size, cipher preferences, hardware overrides)\n\n    All fields are optional or have defaults. See each field for details.\n    \"\"\"\n\n    def __init__(self, **kwargs: Unpack[Params]) -&gt; None:\n        \"\"\"\n        Creates a new TlsOptions.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.TlsOptions.__init__","title":"__init__","text":"<pre><code>__init__(**kwargs)\n</code></pre> <p>Creates a new TlsOptions.</p> Source code in <code>rnet/tls.py</code> <pre><code>def __init__(self, **kwargs: Unpack[Params]) -&gt; None:\n    \"\"\"\n    Creates a new TlsOptions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.TlsInfo","title":"TlsInfo","text":"<p>Information about the established TLS connection.</p> Source code in <code>rnet/tls.py</code> <pre><code>@final\nclass TlsInfo:\n    \"\"\"\n    Information about the established TLS connection.\n    \"\"\"\n\n    def peer_certificate(self) -&gt; bytes | None:\n        \"\"\"\n        Get the DER encoded leaf certificate of the peer.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/tls/#rnet.tls.TlsInfo.peer_certificate","title":"peer_certificate","text":"<pre><code>peer_certificate()\n</code></pre> <p>Get the DER encoded leaf certificate of the peer.</p> Source code in <code>rnet/tls.py</code> <pre><code>def peer_certificate(self) -&gt; bytes | None:\n    \"\"\"\n    Get the DER encoded leaf certificate of the peer.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Examples","text":""},{"location":"examples/advanced/#streaming-request-body","title":"Streaming Request Body","text":"<p>Send data using async generators for streaming uploads:</p> <pre><code>import asyncio\nimport rnet\n\n\nasync def gen():\n    for i in range(10):\n        await asyncio.sleep(0.1)\n\n        if i &lt;= 5:\n            # bytes chunk\n            yield bytes(f\"Hello {i}\\n\", \"utf-8\")\n        else:\n            # str chunk\n            yield str(\"Hello {}\\n\".format(i)).encode(\"utf-8\")\n\n\nasync def main():\n    resp = await rnet.post(\n        \"https://httpbin.io/anything\",\n        body=gen(),\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/advanced/#multipart-file-upload","title":"Multipart File Upload","text":"<p>Upload multiple files and data parts:</p> <pre><code>from pathlib import Path\nimport asyncio\nimport aiofiles\nimport rnet\nfrom rnet import Multipart, Part\n\n\nasync def file_to_bytes_stream(file_path):\n    async with aiofiles.open(file_path, \"rb\") as f:\n        while chunk := await f.read(1024):\n            yield chunk\n\n\nasync def main():\n    resp = await rnet.post(\n        \"https://httpbin.io/anything\",\n        multipart=Multipart(\n            # Upload text data\n            Part(name=\"def\", value=\"111\", filename=\"def.txt\", mime=\"text/plain\"),\n            # Upload binary data\n            Part(name=\"abc\", value=b\"000\", filename=\"abc.txt\", mime=\"text/plain\"),\n            # Upload file data\n            Part(\n                name=\"LICENSE\",\n                value=Path(\"LICENSE\"),\n                filename=\"LICENSE\",\n                mime=\"text/plain\",\n            ),\n            # Upload bytes stream file data\n            Part(\n                name=\"README\",\n                value=file_to_bytes_stream(\"README.md\"),\n                filename=\"README.md\",\n                mime=\"text/plain\",\n            ),\n        ),\n    )\n\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/advanced/#tls-key-logging","title":"TLS Key Logging","text":"<p>Capture TLS keys for debugging with tools like Wireshark:</p> <pre><code>import asyncio\nfrom rnet import Client\nfrom rnet.tls import KeyLog\n\n\nasync def main():\n    client = Client(keylog=KeyLog.file(\"keylog.log\"))\n    resp = await client.get(\"https://www.google.com\")\n    async with resp:\n        print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/advanced/#original-header-order-preservation","title":"Original Header Order Preservation","text":"<p>Preserve header case and order for specific sites:</p> <pre><code>import asyncio\nimport rnet\nfrom rnet.emulation import Emulation\n\n\nasync def main():\n    ws = await rnet.websocket(\n        \"wss://gateway.discord.gg/\",\n        emulation=Emulation.Chrome137,\n        headers={\"Origin\": \"https://discord.com\"},\n        # Preserve HTTP/1 case and header order\n        orig_headers=[\n            \"User-Agent\",\n            \"Origin\",\n            \"Host\",\n            \"Accept\",\n            \"Accept-Encoding\",\n            \"Accept-Language\",\n        ],\n    )\n\n    msg = await ws.recv()\n    if msg is not None:\n        print(msg.json())\n    await ws.close()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/auth/","title":"Authentication Examples","text":""},{"location":"examples/auth/#basic-authentication","title":"Basic Authentication","text":"<pre><code>import asyncio\nimport rnet\n\n\nasync def main():\n    resp = await rnet.get(\n        \"https://httpbin.io/anything\",\n        basic_auth=(\"username\", \"password\"),\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/auth/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<pre><code>import asyncio\nimport rnet\n\n\nasync def main():\n    resp = await rnet.get(\n        \"https://httpbin.io/anything\",\n        bearer_auth=\"token\",\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/auth/#simple-auth-token","title":"Simple Auth Token","text":"<pre><code>import asyncio\nimport rnet\n\n\nasync def main():\n    resp = await rnet.get(\n        \"https://httpbin.io/anything\",\n        auth=\"token\",\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":""},{"location":"examples/basic/#simple-get-request","title":"Simple GET Request","text":"<pre><code>import asyncio\nimport rnet\nfrom rnet import Method\n\n\nasync def main():\n    resp: rnet.Response = await rnet.request(Method.GET, url=\"https://www.google.com/\")\n    print(\"Status Code: \", resp.status)\n    print(\"Version: \", resp.version)\n    print(\"Response URL: \", resp.url)\n    print(\"Headers: \", resp.headers)\n    print(\"Cookies: \", resp.cookies)\n    print(\"Content-Length: \", resp.content_length)\n    print(\"Remote Address: \", resp.remote_addr)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic/#post-request-with-json","title":"POST Request with JSON","text":"<pre><code>import asyncio\nimport rnet\n\n\nasync def main():\n    resp = await rnet.post(\n        \"https://httpbin.io/anything\",\n        json={\"key\": \"value\"},\n    )\n    print(await resp.json())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic/#form-data","title":"Form Data","text":"<pre><code>import asyncio\nimport rnet\n\n\nasync def main():\n    client = rnet.Client()\n\n    # use a list of tuples\n    resp = await client.post(\n        \"https://httpbin.io/anything\",\n        form=[\n            (\"key1\", \"value1\"),\n            (\"key2\", \"value2\"),\n            (\"number\", 123),\n            (\"flag\", True),\n            (\"float\", 45.67),\n        ],\n    )\n    print(await resp.text())\n\n    # OR use a dictionary\n    resp = await client.post(\n        \"https://httpbin.io/anything\",\n        form={\n            \"keyA\": \"valueA\",\n            \"keyB\": \"valueB\",\n            \"number\": 789,\n            \"flag\": False,\n            \"float\": 12.34,\n        },\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic/#custom-headers","title":"Custom Headers","text":"<pre><code>from rnet.header import HeaderMap\n\n\nif __name__ == \"__main__\":\n    headers = HeaderMap()\n    # Add Content-Type header\n    headers.insert(\"Content-Type\", \"application/json\")\n    # Add Accept header (first value)\n    headers.insert(\"Accept\", \"application/json\")\n    # Add Accept header (second value)\n    headers.insert(\"Accept\", \"text/html\")\n    # Get all values for 'Accept' header\n    print(\"All Accept:\", list(headers.get_all(\"Accept\")))\n    # Get the value for 'Content-Type' header\n    print(\"Content-Type:\", headers.get(\"Content-Type\"))\n</code></pre>"},{"location":"examples/basic/#query-parameters","title":"Query Parameters","text":"<pre><code>import asyncio\nimport rnet\n\n\nasync def main():\n    # Send list of tuples as query parameters\n    resp = await rnet.get(\n        \"https://httpbin.io/anything\",\n        query=[\n            (\"key1\", \"value1\"),\n            (\"key2\", \"value2\"),\n            (\"number\", 123),\n            (\"flag\", True),\n            (\"float\", 45.67),\n        ],\n    )\n    print(await resp.text())\n\n    # OR send dictionary as query parameters\n    resp = await rnet.get(\n        \"https://httpbin.io/anything\",\n        query={\n            \"keyA\": \"valueA\",\n            \"keyB\": \"valueB\",\n            \"number\": 789,\n            \"flag\": False,\n            \"float\": 12.34,\n        },\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic/#streaming-response","title":"Streaming Response","text":"<pre><code>import asyncio\nimport rnet\nfrom rnet import Response\n\n\nasync def main():\n    resp: Response = await rnet.get(\"https://httpbin.io/stream/20\")\n    async with resp:\n        async with resp.stream() as streamer:\n            async for chunk in streamer:\n                print(chunk)\n                await asyncio.sleep(0.1)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom rnet import Client\n\nasync def main():\n    client = Client()\n    resp = await client.get(\"https://httpbin.org/stream/10\")\n\n    async for chunk in resp.stream():\n        print(chunk.decode('utf-8'))\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/blocking/","title":"Blocking/Synchronous API Examples","text":"<p>The blocking API provides synchronous methods for environments where async/await is not needed.</p>"},{"location":"examples/blocking/#simple-get-request","title":"Simple GET Request","text":"<pre><code>import datetime\nfrom rnet.blocking import Client\nfrom rnet.emulation import Emulation\n\n\ndef main():\n    client = Client()\n    resp = client.get(\n        \"https://tls.peet.ws/api/all\",\n        timeout=datetime.timedelta(seconds=10),\n        emulation=Emulation.Firefox139,\n    )\n    print(resp.text())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/blocking/#client-configuration","title":"Client Configuration","text":"<pre><code>from rnet import Proxy\nfrom rnet.blocking import Client\nfrom rnet.emulation import Emulation\n\n\ndef main():\n    client = Client(\n        emulation=Emulation.Firefox133,\n        user_agent=\"rnet\",\n        proxies=[\n            Proxy.http(\"socks5h://abc:def@127.0.0.1:1080\"),\n            Proxy.https(url=\"socks5h://127.0.0.1:1080\", username=\"abc\", password=\"def\"),\n            Proxy.http(url=\"http://abc:def@127.0.0.1:1080\", custom_http_auth=\"abcedf\"),\n            Proxy.all(\n                url=\"socks5h://abc:def@127.0.0.1:1080\",\n                exclusion=\"google.com, facebook.com, twitter.com\",\n            ),\n        ],\n    )\n    resp = client.get(\"https://api.ip.sb/ip\")\n    print(\"Status Code: \", resp.status)\n    print(\"Version: \", resp.version)\n    print(\"Response URL: \", resp.url)\n    print(\"Headers: \", resp.headers)\n    print(\"Content-Length: \", resp.content_length)\n    print(\"Remote Address: \", resp.remote_addr)\n    print(\"Text: \", resp.text())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/blocking/#cookies","title":"Cookies","text":"<pre><code>from rnet.blocking import Client, Method\n\n\ndef main():\n    client = Client()\n    resp = client.request(Method.GET, \"https://www.google.com/\")\n    for resp in resp.cookies:\n        print(f\"{resp.name}: {resp.value}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/blocking/#authentication","title":"Authentication","text":"<pre><code>from rnet.blocking import Client\n\n\ndef main():\n    # Basic auth\n    resp = Client().get(\n        \"https://httpbin.io/anything\",\n        basic_auth=(\"username\", \"password\"),\n    )\n    print(resp.text())\n\n    # Bearer token\n    resp = Client().get(\n        \"https://httpbin.io/anything\",\n        bearer_auth=\"token\",\n    )\n    print(resp.text())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/blocking/#json-and-form-data","title":"JSON and Form Data","text":"<pre><code>from rnet.blocking import Client\n\n\ndef main():\n    client = Client()\n\n    # JSON request\n    resp = client.post(\n        \"https://httpbin.io/anything\",\n        json={\"key\": \"value\"},\n    )\n    print(resp.json())\n\n    # Form data\n    resp = client.post(\n        \"https://httpbin.io/anything\",\n        form={\n            \"keyA\": \"valueA\",\n            \"keyB\": \"valueB\",\n            \"number\": 789,\n        },\n    )\n    print(resp.text())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/blocking/#query-parameters","title":"Query Parameters","text":"<pre><code>from rnet.blocking import Client\n\n\ndef main():\n    client = Client()\n    resp = client.get(\n        \"https://httpbin.io/anything\",\n        query={\n            \"keyA\": \"valueA\",\n            \"keyB\": \"valueB\",\n            \"number\": 789,\n        },\n    )\n    print(resp.text())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/blocking/#streaming-response","title":"Streaming Response","text":"<pre><code>from rnet.blocking import Client\n\n\ndef main():\n    client = Client()\n    resp = client.get(\"https://httpbin.io/stream/20\")\n    with resp:\n        with resp.stream() as streamer:\n            for chunk in streamer:\n                print(chunk)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/emulation/","title":"Browser Emulation Examples","text":""},{"location":"examples/emulation/#simple-firefox-emulation","title":"Simple Firefox Emulation","text":"<pre><code>import asyncio\nfrom rnet import Client\nfrom rnet.emulation import Emulation\n\n\nasync def main():\n    client = Client(\n        emulation=Emulation.Firefox135,\n    )\n    resp = await client.get(\"https://tls.peet.ws/api/all\")\n    print(f\"Status: {resp.status}\")\n    print(f\"Content: {await resp.text()}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/emulation/#chrome-on-android-emulation","title":"Chrome on Android Emulation","text":"<pre><code>import asyncio\nfrom rnet import Client\nfrom rnet.emulation import Emulation, EmulationOS, EmulationOption\n\n\nasync def main():\n    client = Client()\n    resp = await client.get(\n        \"https://tls.peet.ws/api/all\",\n        emulation=EmulationOption(\n            emulation=Emulation.Chrome134,\n            emulation_os=EmulationOS.Android,\n        ),\n        # Disable client default headers\n        default_headers=False,\n    )\n    print(f\"Status: {resp.status}\")\n    print(f\"Content: {await resp.text()}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/emulation/#advanced-configuration-with-custom-tls-and-http2","title":"Advanced Configuration with Custom TLS and HTTP/2","text":"<pre><code>import asyncio\nfrom rnet import Client\nfrom rnet.tls import TlsOptions, TlsVersion, AlpnProtocol\nfrom rnet.http2 import Http2Options, PseudoId, PseudoOrder\nfrom rnet.header import HeaderMap, OrigHeaderMap\n\n\nasync def main():\n    # TLS options configuration\n    tls_options = TlsOptions(\n        grease_enabled=True,\n        enable_ocsp_stapling=True,\n        curves_list=\":\".join([\"X25519\", \"P-256\", \"P-384\"]),\n        cipher_list=\":\".join(\n            [\n                \"TLS_AES_128_GCM_SHA256\",\n                \"TLS_AES_256_GCM_SHA384\",\n                \"TLS_CHACHA20_POLY1305_SHA256\",\n                \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n                \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n            ]\n        ),\n        sigalgs_list=\":\".join(\n            [\n                \"ecdsa_secp256r1_sha256\",\n                \"rsa_pss_rsae_sha256\",\n                \"rsa_pkcs1_sha256\",\n            ]\n        ),\n        alpn_protocols=[AlpnProtocol.HTTP2, AlpnProtocol.HTTP1],\n        min_tls_version=TlsVersion.TLS_1_2,\n        max_tls_version=TlsVersion.TLS_1_3,\n    )\n\n    # HTTP/2 options configuration\n    http2_options = Http2Options(\n        initial_stream_id=3,\n        initial_window_size=16777216,\n        initial_connection_window_size=16711681 + 65535,\n        headers_pseudo_order=PseudoOrder(\n            PseudoId.METHOD,\n            PseudoId.PATH,\n            PseudoId.AUTHORITY,\n            PseudoId.SCHEME,\n        ),\n    )\n\n    # Default headers\n    headers = HeaderMap()\n    headers.insert(\"User-Agent\", \"CustomAgent/1.0\")\n    headers.insert(\"Accept-Language\", \"en-US\")\n    headers.insert(\"Accept-Encoding\", \"br, gzip, deflate\")\n\n    # Original headers to preserve case and order\n    orig_headers = OrigHeaderMap()\n    orig_headers.insert(\"User-Agent\")\n    orig_headers.insert(\"Accept-Language\")\n    orig_headers.insert(\"Accept-Encoding\")\n\n    # Create client with advanced configuration\n    client = Client(\n        tls_options=tls_options,\n        http2_options=http2_options,\n        headers=headers,\n        orig_headers=orig_headers,\n    )\n\n    resp = await client.post(\"https://tls.peet.ws/api/all\")\n    print(f\"Status: {resp.status}\")\n    print(f\"Content: {await resp.text()}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/proxy/","title":"Proxy Examples","text":""},{"location":"examples/proxy/#httphttps-proxy","title":"HTTP/HTTPS Proxy","text":"<p>Using proxies with authentication:</p> <pre><code>import asyncio\nimport rnet\nfrom rnet import Client, Proxy\n\n\nasync def main():\n    # Create a client with multiple proxies\n    client = Client(\n        proxies=[Proxy.http(\"socks5h://abc:def@127.0.0.1:6152\")],\n    )\n\n    # Send request via the client proxy\n    resp = await client.get(\"https://httpbin.io/anything\")\n    print(await resp.text())\n\n    # Send request via custom proxy\n    resp = await rnet.get(\n        \"https://httpbin.io/anything\",\n        proxy=Proxy.all(\n            url=\"http://127.0.0.1:6152\",\n            custom_http_headers={\n                \"user-agent\": \"rnet\",\n                \"accept\": \"*/*\",\n                \"accept-encoding\": \"gzip, deflate, br\",\n                \"x-proxy\": \"rnet\",\n            },\n        ),\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/proxy/#unix-socket-proxy","title":"Unix Socket Proxy","text":"<p>Using Unix sockets for local services like Docker:</p> <pre><code>import asyncio\nimport rnet\nfrom rnet import Proxy\n\n\nasync def main():\n    # Send request via Unix socket proxy\n    resp = await rnet.get(\n        \"http://localhost/v1.41/containers/json\",\n        proxy=Proxy.unix(\"/var/run/docker.sock\"),\n    )\n    print(await resp.text())\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/redirect-errors/","title":"Redirect and Error Handling Examples","text":""},{"location":"examples/redirect-errors/#custom-redirect-policy","title":"Custom Redirect Policy","text":"<p>Control redirect behavior with custom policies:</p> <pre><code>import asyncio\nfrom rnet import Client, Response, redirect\nfrom rnet.redirect import Attempt, Action\n\n\ndef custom_policy(attempt: Attempt) -&gt; Action:\n    \"\"\"Custom redirect policy that blocks example.com redirects.\"\"\"\n    print(\n        f\"Redirect to: {attempt.next} (status: {attempt.status}) (headers: {attempt.headers})\"\n    )\n\n    # Block redirects to example.com\n    if \"example.com\" in attempt.next:\n        return attempt.stop()\n\n    # Limit redirect chain length\n    if len(attempt.previous) &gt; 5:\n        return attempt.error(\"Too many redirects\")\n\n    # Allow other redirects\n    return attempt.follow()\n\n\nasync def main():\n    # Create a client with custom redirect policy\n    policy = redirect.Policy.custom(custom_policy)\n    client = Client(redirect=policy)\n\n    # Test with a URL that redirects\n    response: Response = await client.get(\"http://httpbin.io/redirect/3\")\n    print(f\"Final URL: {response.url}\")\n    print(f\"Status: {response.status}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/redirect-errors/#error-handling","title":"Error Handling","text":"<p>Handle various request exceptions:</p> <pre><code>import datetime\nimport rnet\nimport asyncio\nimport rnet.exceptions as exceptions\n\nrnet_errors = (\n    exceptions.BodyError,\n    exceptions.BuilderError,\n    exceptions.ConnectionError,\n    exceptions.ConnectionResetError,\n    exceptions.DecodingError,\n    exceptions.RedirectError,\n    exceptions.TimeoutError,\n    exceptions.StatusError,\n    exceptions.RequestError,\n    exceptions.UpgradeError,\n)\n\n\nasync def test_timeout_error():\n    print(\"\\n--- TimeoutError (timeout) ---\")\n    try:\n        await rnet.get(\n            \"https://httpbin.io/delay/10\", timeout=datetime.timedelta(seconds=1)\n        )\n    except rnet_errors as e:\n        print(f\"Caught: {type(e).__name__}: {e}\")\n    except Exception as e:\n        print(f\"Other error: {type(e).__name__}: {e}\")\n\n\nasync def test_connection_error():\n    print(\"\\n--- ConnectionError (refused) ---\")\n    try:\n        await rnet.get(\"http://127.0.0.1:9999\")\n    except rnet_errors as e:\n        print(f\"Caught: {type(e).__name__}: {e}\")\n    except Exception as e:\n        print(f\"Other error: {type(e).__name__}: {e}\")\n\n\nasync def main():\n    await test_timeout_error()\n    await test_connection_error()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/websocket/","title":"WebSocket Examples","text":""},{"location":"examples/websocket/#http11-websocket-connection","title":"HTTP/1.1 WebSocket Connection","text":"<pre><code>import asyncio\nimport datetime\nimport rnet\nfrom rnet import Message, WebSocket\nfrom rnet import exceptions\n\n\nasync def send_message(ws: WebSocket):\n    print(\"Starting to send messages...\")\n    for i in range(20):\n        print(f\"Sending: Message {i + 1}\")\n        await ws.send(Message.from_text(f\"Message {i + 1}\"))\n        await asyncio.sleep(0.1)\n\n\nasync def recv_message(ws: WebSocket):\n    print(\"Starting to receive messages...\")\n    while True:\n        try:\n            message = await ws.recv(timeout=datetime.timedelta(milliseconds=10))\n            print(\"Received: \", message)\n            if message is None:\n                print(\"Connection closed by server.\")\n                break\n\n            if message.data == b\"Message 20\":\n                print(\"Closing connection...\")\n                break\n        except exceptions.TimeoutError:\n            continue\n\n\nasync def main():\n    client = rnet.Client()\n    ws: WebSocket = await client.websocket(\"wss://echo.websocket.org\")\n    async with ws:\n        print(\"Status Code: \", ws.status)\n        print(\"Version: \", ws.version)\n        print(\"Headers: \", ws.headers)\n        print(\"Remote Address: \", ws.remote_addr)\n\n        if ws.status == 101:\n            print(\"WebSocket connection established successfully.\")\n            send_task = asyncio.create_task(send_message(ws))\n            receive_task = asyncio.create_task(recv_message(ws))\n            await asyncio.gather(send_task, receive_task)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/websocket/#http2-websocket-connection","title":"HTTP/2 WebSocket Connection","text":"<pre><code>import asyncio\nimport datetime\nimport rnet\nfrom rnet import Message, WebSocket\nfrom rnet import exceptions\n\n\nasync def send_message(ws):\n    print(\"Starting to send messages...\")\n    for i in range(20):\n        print(f\"Sending: Message {i + 1}\")\n        await ws.send(Message.from_text(f\"Message {i + 1}\"))\n        await asyncio.sleep(0.1)\n\n\nasync def recv_message(ws):\n    print(\"Starting to receive messages...\")\n    while True:\n        try:\n            message = await ws.recv(timeout=datetime.timedelta(milliseconds=10))\n            print(\"Received: \", message)\n            if message is None:\n                print(\"Connection closed by server.\")\n                break\n\n            if message.data == b\"Message 20\":\n                print(\"Closing connection...\")\n                break\n        except exceptions.TimeoutError:\n            continue\n\n\nasync def main():\n    # Connect to HTTP/2 WebSocket server with force_http2=True\n    client = rnet.Client(verify=False)\n    ws: WebSocket = await client.websocket(\n        \"wss://127.0.0.1:3000/ws\",\n        force_http2=True\n    )\n    async with ws:\n        print(\"Status Code: \", ws.status)\n        print(\"Version: \", ws.version)\n        print(\"Headers: \", ws.headers)\n        print(\"Remote Address: \", ws.remote_addr)\n\n        if ws.status == 200:\n            print(\"WebSocket connection established successfully.\")\n            send_task = asyncio.create_task(send_message(ws))\n            receive_task = asyncio.create_task(recv_message(ws))\n            await asyncio.gather(send_task, receive_task)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>HTTP/2 WebSocket Testing</p> <p>To test HTTP/2 WebSocket, you need to run a local server:</p> <pre><code>git clone https://github.com/tokio-rs/axum &amp;&amp; cd axum\ncargo run -p example-websockets-http2\n</code></pre> <p>Then run the Python script to connect to the websocket server.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The simplest way to install rnet is from PyPI:</p> <pre><code>pip install rnet\n</code></pre> <p>Or using uv:</p> <pre><code>uv pip install rnet\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>To install the latest development version:</p> <pre><code>git clone https://github.com/0x676e67/rnet.git\ncd rnet\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Verify that rnet is installed correctly:</p> <pre><code>import rnet\nprint(rnet.__version__)\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Continue to the Quick Start guide to learn how to use rnet.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with rnet quickly.</p>"},{"location":"getting-started/quickstart/#basic-get-request","title":"Basic GET Request","text":""},{"location":"getting-started/quickstart/#async","title":"Async","text":"<pre><code>import asyncio\nfrom rnet import Client\n\nasync def main():\n    client = Client()\n    resp = await client.get(\"https://httpbin.org/get\")\n    print(resp.status_code)\n    print(await resp.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#blocking","title":"Blocking","text":"<pre><code>from rnet.blocking import Client\n\nclient = Client()\nresp = client.get(\"https://httpbin.org/get\")\nprint(resp.status_code)\nprint(resp.text())\n</code></pre>"},{"location":"getting-started/quickstart/#post-with-json","title":"POST with JSON","text":"<pre><code>import asyncio\nfrom rnet import Client\n\nasync def main():\n    client = Client()\n    data = {\"name\": \"John\", \"age\": 30}\n    resp = await client.post(\"https://httpbin.org/post\", json=data)\n    result = await resp.json()\n    print(result)\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#browser-emulation","title":"Browser Emulation","text":"<p>Emulate different browsers to bypass detection:</p> <pre><code>import asyncio\nfrom rnet import Client, Emulation\n\nasync def main():\n    # Emulate Chrome 120\n    client = Client(emulation=Emulation.Chrome120)\n    resp = await client.get(\"https://httpbin.org/get\")\n    print(await resp.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#using-proxies","title":"Using Proxies","text":"<pre><code>import asyncio\nfrom rnet import Client\nfrom rnet.proxy import Proxy\n\nasync def main():\n    proxy = Proxy.http(\"http://proxy.example.com:8080\")\n    client = Client(proxy=proxy)\n    resp = await client.get(\"https://httpbin.org/ip\")\n    print(await resp.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#custom-headers","title":"Custom Headers","text":"<pre><code>import asyncio\nfrom rnet import Client\nfrom rnet.header import HeaderMap\n\nasync def main():\n    client = Client()\n    headers = HeaderMap()\n    headers[\"User-Agent\"] = \"MyApp/1.0\"\n    headers[\"Custom-Header\"] = \"value\"\n\n    resp = await client.get(\"https://httpbin.org/headers\", headers=headers)\n    print(await resp.text())\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed documentation</li> <li>Check out Examples for more code samples</li> <li>Learn about Browser Emulation for advanced use cases</li> </ul>"}]}